"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gaxios";
exports.ids = ["vendor-chunks/gaxios"];
exports.modules = {

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/common.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GaxiosError = exports.GAXIOS_ERROR_SYMBOL = void 0;\nexports.defaultErrorRedactor = defaultErrorRedactor;\nconst extend_1 = __importDefault(__webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\"));\nconst util_cjs_1 = __importDefault(__webpack_require__(/*! ./util.cjs */ \"(rsc)/./node_modules/gaxios/build/cjs/src/util.cjs\"));\nconst pkg = util_cjs_1.default.pkg;\n/**\n * Support `instanceof` operator for `GaxiosError`s in different versions of this library.\n *\n * @see {@link GaxiosError[Symbol.hasInstance]}\n */ exports.GAXIOS_ERROR_SYMBOL = Symbol.for(`${pkg.name}-gaxios-error`);\nlet prop;\nclass GaxiosError extends Error {\n    static{\n        prop = exports.GAXIOS_ERROR_SYMBOL;\n    }\n    /**\n     * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.\n     *\n     * @see {@link GAXIOS_ERROR_SYMBOL}\n     * @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}\n     */ static [Symbol.hasInstance](instance) {\n        if (instance && typeof instance === \"object\" && exports.GAXIOS_ERROR_SYMBOL in instance && instance[exports.GAXIOS_ERROR_SYMBOL] === pkg.version) {\n            return true;\n        }\n        // fallback to native\n        return Function.prototype[Symbol.hasInstance].call(GaxiosError, instance);\n    }\n    constructor(message, config, response, cause){\n        super(message, {\n            cause\n        });\n        /**\n     * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.\n     *\n     * @see {@link GAXIOS_ERROR_SYMBOL}\n     * @see {@link GaxiosError[Symbol.hasInstance]}\n     * @see {@link https://github.com/microsoft/TypeScript/issues/13965#issuecomment-278570200}\n     * @see {@link https://stackoverflow.com/questions/46618852/require-and-instanceof}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/@@hasInstance#reverting_to_default_instanceof_behavior}\n     */ this[prop] = pkg.version;\n        this.config = config;\n        this.response = response;\n        this.error = cause instanceof Error ? cause : undefined;\n        // deep-copy config as we do not want to mutate\n        // the existing config for future retries/use\n        this.config = (0, extend_1.default)(true, {}, config);\n        if (this.response) {\n            this.response.config = (0, extend_1.default)(true, {}, this.response.config);\n        }\n        if (this.response) {\n            try {\n                this.response.data = translateData(this.config.responseType, // workaround for `node-fetch`'s `.data` deprecation...\n                this.response?.bodyUsed ? this.response?.data : undefined);\n            } catch  {\n            // best effort - don't throw an error within an error\n            // we could set `this.response.config.responseType = 'unknown'`, but\n            // that would mutate future calls with this config object.\n            }\n            this.status = this.response.status;\n        }\n        if (cause instanceof DOMException) {\n            // The DOMException's equivalent to code is its name\n            // E.g.: name = `TimeoutError`, code = number\n            // https://developer.mozilla.org/en-US/docs/Web/API/DOMException/name\n            this.code = cause.name;\n        } else if (cause && typeof cause === \"object\" && \"code\" in cause && (typeof cause.code === \"string\" || typeof cause.code === \"number\")) {\n            this.code = cause.code;\n        }\n    }\n    /**\n     * An AIP-193 conforming error extractor.\n     *\n     * @see {@link https://google.aip.dev/193#http11json-representation AIP-193}\n     *\n     * @internal\n     * @expiremental\n     *\n     * @param res the response object\n     * @returns the extracted error information\n     */ static extractAPIErrorFromResponse(res, defaultErrorMessage = \"The request failed\") {\n        let message = defaultErrorMessage;\n        // Use res.data as the error message\n        if (typeof res.data === \"string\") {\n            message = res.data;\n        }\n        if (res.data && typeof res.data === \"object\" && \"error\" in res.data && res.data.error && !res.ok) {\n            if (typeof res.data.error === \"string\") {\n                return {\n                    message: res.data.error,\n                    code: res.status,\n                    status: res.statusText\n                };\n            }\n            if (typeof res.data.error === \"object\") {\n                // extract status from data.message\n                message = \"message\" in res.data.error && typeof res.data.error.message === \"string\" ? res.data.error.message : message;\n                // extract status from data.error\n                const status = \"status\" in res.data.error && typeof res.data.error.status === \"string\" ? res.data.error.status : res.statusText;\n                // extract code from data.error\n                const code = \"code\" in res.data.error && typeof res.data.error.code === \"number\" ? res.data.error.code : res.status;\n                if (\"errors\" in res.data.error && Array.isArray(res.data.error.errors)) {\n                    const errorMessages = [];\n                    for (const e of res.data.error.errors){\n                        if (typeof e === \"object\" && \"message\" in e && typeof e.message === \"string\") {\n                            errorMessages.push(e.message);\n                        }\n                    }\n                    return Object.assign({\n                        message: errorMessages.join(\"\\n\") || message,\n                        code,\n                        status\n                    }, res.data.error);\n                }\n                return Object.assign({\n                    message,\n                    code,\n                    status\n                }, res.data.error);\n            }\n        }\n        return {\n            message,\n            code: res.status,\n            status: res.statusText\n        };\n    }\n}\nexports.GaxiosError = GaxiosError;\nfunction translateData(responseType, data) {\n    switch(responseType){\n        case \"stream\":\n            return data;\n        case \"json\":\n            return JSON.parse(JSON.stringify(data));\n        case \"arraybuffer\":\n            return JSON.parse(Buffer.from(data).toString(\"utf8\"));\n        case \"blob\":\n            return JSON.parse(data.text());\n        default:\n            return data;\n    }\n}\n/**\n * An experimental error redactor.\n *\n * @param config Config to potentially redact properties of\n * @param response Config to potentially redact properties of\n *\n * @experimental\n */ function defaultErrorRedactor(data) {\n    const REDACT = \"<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.\";\n    function redactHeaders(headers) {\n        if (!headers) return;\n        headers.forEach((_, key)=>{\n            // any casing of `Authentication`\n            // any casing of `Authorization`\n            // anything containing secret, such as 'client secret'\n            if (/^authentication$/i.test(key) || /^authorization$/i.test(key) || /secret/i.test(key)) headers.set(key, REDACT);\n        });\n    }\n    function redactString(obj, key) {\n        if (typeof obj === \"object\" && obj !== null && typeof obj[key] === \"string\") {\n            const text = obj[key];\n            if (/grant_type=/i.test(text) || /assertion=/i.test(text) || /secret/i.test(text)) {\n                obj[key] = REDACT;\n            }\n        }\n    }\n    function redactObject(obj) {\n        if (!obj || typeof obj !== \"object\") {\n            return;\n        } else if (obj instanceof FormData || obj instanceof URLSearchParams || // support `node-fetch` FormData/URLSearchParams\n        \"forEach\" in obj && \"set\" in obj) {\n            obj.forEach((_, key)=>{\n                if ([\n                    \"grant_type\",\n                    \"assertion\"\n                ].includes(key) || /secret/.test(key)) {\n                    obj.set(key, REDACT);\n                }\n            });\n        } else {\n            if (\"grant_type\" in obj) {\n                obj[\"grant_type\"] = REDACT;\n            }\n            if (\"assertion\" in obj) {\n                obj[\"assertion\"] = REDACT;\n            }\n            if (\"client_secret\" in obj) {\n                obj[\"client_secret\"] = REDACT;\n            }\n        }\n    }\n    if (data.config) {\n        redactHeaders(data.config.headers);\n        redactString(data.config, \"data\");\n        redactObject(data.config.data);\n        redactString(data.config, \"body\");\n        redactObject(data.config.body);\n        if (data.config.url.searchParams.has(\"token\")) {\n            data.config.url.searchParams.set(\"token\", REDACT);\n        }\n        if (data.config.url.searchParams.has(\"client_secret\")) {\n            data.config.url.searchParams.set(\"client_secret\", REDACT);\n        }\n    }\n    if (data.response) {\n        defaultErrorRedactor({\n            config: data.response.config\n        });\n        redactHeaders(data.response.headers);\n        // workaround for `node-fetch`'s `.data` deprecation...\n        if (data.response.bodyUsed) {\n            redactString(data.response, \"data\");\n            redactObject(data.response.data);\n        }\n    }\n    return data;\n} //# sourceMappingURL=common.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixnREFBZ0Q7QUFDaEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUN6REEsNEJBQTRCLEdBQUdJO0FBQy9CLE1BQU1DLFdBQVdWLGdCQUFnQlcsbUJBQU9BLENBQUMsb0RBQVE7QUFDakQsTUFBTUMsYUFBYVosZ0JBQWdCVyxtQkFBT0EsQ0FBQyxzRUFBWTtBQUN2RCxNQUFNRSxNQUFNRCxXQUFXRSxPQUFPLENBQUNELEdBQUc7QUFDbEM7Ozs7Q0FJQyxHQUNEUiwyQkFBMkIsR0FBR1UsT0FBT0MsR0FBRyxDQUFDLENBQUMsRUFBRUgsSUFBSUksSUFBSSxDQUFDLGFBQWEsQ0FBQzs7QUFDbkUsTUFBTVYsb0JBQW9CVzs7ZUFxRHJCYixRQUFRRyxtQkFBbUI7O0lBQzVCOzs7OztLQUtDLEdBQ0QsT0FBTyxDQUFDTyxPQUFPSSxXQUFXLENBQUMsQ0FBQ0MsUUFBUSxFQUFFO1FBQ2xDLElBQUlBLFlBQ0EsT0FBT0EsYUFBYSxZQUNwQmYsUUFBUUcsbUJBQW1CLElBQUlZLFlBQy9CQSxRQUFRLENBQUNmLFFBQVFHLG1CQUFtQixDQUFDLEtBQUtLLElBQUlRLE9BQU8sRUFBRTtZQUN2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NUMsS0FBS0wsTUFBTSxDQUFDK0MsR0FBRyxDQUFDQyxZQUFZLENBQUNULEdBQUcsQ0FBQyxpQkFBaUJQO1FBQ3REO0lBQ0o7SUFDQSxJQUFJM0IsS0FBS0osUUFBUSxFQUFFO1FBQ2ZuQixxQkFBcUI7WUFBRWtCLFFBQVFLLEtBQUtKLFFBQVEsQ0FBQ0QsTUFBTTtRQUFDO1FBQ3BEaUMsY0FBYzVCLEtBQUtKLFFBQVEsQ0FBQ2lDLE9BQU87UUFDbkMsdURBQXVEO1FBQ3ZELElBQUk3QixLQUFLSixRQUFRLENBQUNPLFFBQVEsRUFBRTtZQUN4QmdDLGFBQWFuQyxLQUFLSixRQUFRLEVBQUU7WUFDNUJ5QyxhQUFhckMsS0FBS0osUUFBUSxDQUFDSSxJQUFJO1FBQ25DO0lBQ0o7SUFDQSxPQUFPQTtBQUNYLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluay1zYXZlci1hdXRvLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvY29tbW9uLmpzPzk1MGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2F4aW9zRXJyb3IgPSBleHBvcnRzLkdBWElPU19FUlJPUl9TWU1CT0wgPSB2b2lkIDA7XG5leHBvcnRzLmRlZmF1bHRFcnJvclJlZGFjdG9yID0gZGVmYXVsdEVycm9yUmVkYWN0b3I7XG5jb25zdCBleHRlbmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXh0ZW5kXCIpKTtcbmNvbnN0IHV0aWxfY2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbC5janNcIikpO1xuY29uc3QgcGtnID0gdXRpbF9janNfMS5kZWZhdWx0LnBrZztcbi8qKlxuICogU3VwcG9ydCBgaW5zdGFuY2VvZmAgb3BlcmF0b3IgZm9yIGBHYXhpb3NFcnJvcmBzIGluIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkuXG4gKlxuICogQHNlZSB7QGxpbmsgR2F4aW9zRXJyb3JbU3ltYm9sLmhhc0luc3RhbmNlXX1cbiAqL1xuZXhwb3J0cy5HQVhJT1NfRVJST1JfU1lNQk9MID0gU3ltYm9sLmZvcihgJHtwa2cubmFtZX0tZ2F4aW9zLWVycm9yYCk7XG5jbGFzcyBHYXhpb3NFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25maWc7XG4gICAgcmVzcG9uc2U7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3IgY29kZS5cbiAgICAgKiBDYW4gYmUgYSBzeXN0ZW0gZXJyb3IgY29kZSwgRE9NRXhjZXB0aW9uIGVycm9yIG5hbWUsIG9yIGFueSBlcnJvcidzICdjb2RlJyBwcm9wZXJ0eSB3aGVyZSBpdCBpcyBhIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogSXQgaXMgb25seSBhIGBudW1iZXJgIHdoZW4gdGhlIGNhdXNlIGlzIHNvdXJjZWQgZnJvbSBhbiBBUEktbGV2ZWwgZXJyb3IgKEFJUC0xOTMpLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9lcnJvcnMuaHRtbCNlcnJvcmNvZGUgZXJyb3IuY29kZX1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NRXhjZXB0aW9uI2Vycm9yX25hbWVzIERPTUV4Y2VwdGlvbiNlcnJvcl9uYW1lc31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dvb2dsZS5haXAuZGV2LzE5MyNodHRwMTFqc29uLXJlcHJlc2VudGF0aW9uIEFJUC0xOTN9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICdFQ09OTlJFU0VUJ1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAnVGltZW91dEVycm9yJ1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiA1MDBcbiAgICAgKi9cbiAgICBjb2RlO1xuICAgIC8qKlxuICAgICAqIEFuIEhUVFAgU3RhdHVzIGNvZGUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc3BvbnNlL3N0YXR1cyBSZXNwb25zZSNzdGF0dXN9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDUwMFxuICAgICAqL1xuICAgIHN0YXR1cztcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIEdheGlvc0Vycm9yLmNhdXNlfSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IvY2F1c2UgRXJyb3IjY2F1c2V9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVJlbWFya3NcbiAgICAgKlxuICAgICAqIFdlIHdpbGwgd2FudCB0byByZW1vdmUgdGhpcyBwcm9wZXJ0eSBsYXRlciBhcyB0aGUgbW9kZXJuIGBjYXVzZWAgcHJvcGVydHkgaXMgYmV0dGVyIHN1aXRlZFxuICAgICAqIGZvciBkaXNwbGF5aW5nIGFuZCByZWxheWluZyBuZXN0ZWQgZXJyb3JzLiBLZWVwaW5nIHRoaXMgaGVyZSBtYWtlcyB0aGUgcmVzdWx0aW5nXG4gICAgICogZXJyb3IgbG9nIGxhcmdlciB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBgaW5zdGFuY2VvZmAgb3BlcmF0b3IgZm9yIGBHYXhpb3NFcnJvcmAgYWNyb3NzIGJ1aWxkcy9kdXBsaWNhdGVkIGZpbGVzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgR0FYSU9TX0VSUk9SX1NZTUJPTH1cbiAgICAgKiBAc2VlIHtAbGluayBHYXhpb3NFcnJvcltTeW1ib2wuaGFzSW5zdGFuY2VdfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTM5NjUjaXNzdWVjb21tZW50LTI3ODU3MDIwMH1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NjYxODg1Mi9yZXF1aXJlLWFuZC1pbnN0YW5jZW9mfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL0BAaGFzSW5zdGFuY2UjcmV2ZXJ0aW5nX3RvX2RlZmF1bHRfaW5zdGFuY2VvZl9iZWhhdmlvcn1cbiAgICAgKi9cbiAgICBbZXhwb3J0cy5HQVhJT1NfRVJST1JfU1lNQk9MXSA9IHBrZy52ZXJzaW9uO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgYGluc3RhbmNlb2ZgIG9wZXJhdG9yIGZvciBgR2F4aW9zRXJyb3JgIGFjcm9zcyBidWlsZHMvZHVwbGljYXRlZCBmaWxlcy5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEdBWElPU19FUlJPUl9TWU1CT0x9XG4gICAgICogQHNlZSB7QGxpbmsgR2F4aW9zRXJyb3JbR0FYSU9TX0VSUk9SX1NZTUJPTF19XG4gICAgICovXG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZXhwb3J0cy5HQVhJT1NfRVJST1JfU1lNQk9MIGluIGluc3RhbmNlICYmXG4gICAgICAgICAgICBpbnN0YW5jZVtleHBvcnRzLkdBWElPU19FUlJPUl9TWU1CT0xdID09PSBwa2cudmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbmF0aXZlXG4gICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKEdheGlvc0Vycm9yLCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvbmZpZywgcmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBjYXVzZSBpbnN0YW5jZW9mIEVycm9yID8gY2F1c2UgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGRlZXAtY29weSBjb25maWcgYXMgd2UgZG8gbm90IHdhbnQgdG8gbXV0YXRlXG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBjb25maWcgZm9yIGZ1dHVyZSByZXRyaWVzL3VzZVxuICAgICAgICB0aGlzLmNvbmZpZyA9ICgwLCBleHRlbmRfMS5kZWZhdWx0KSh0cnVlLCB7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UuY29uZmlnID0gKDAsIGV4dGVuZF8xLmRlZmF1bHQpKHRydWUsIHt9LCB0aGlzLnJlc3BvbnNlLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5kYXRhID0gdHJhbnNsYXRlRGF0YSh0aGlzLmNvbmZpZy5yZXNwb25zZVR5cGUsIFxuICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGBub2RlLWZldGNoYCdzIGAuZGF0YWAgZGVwcmVjYXRpb24uLi5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlPy5ib2R5VXNlZCA/IHRoaXMucmVzcG9uc2U/LmRhdGEgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIGJlc3QgZWZmb3J0IC0gZG9uJ3QgdGhyb3cgYW4gZXJyb3Igd2l0aGluIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gd2UgY291bGQgc2V0IGB0aGlzLnJlc3BvbnNlLmNvbmZpZy5yZXNwb25zZVR5cGUgPSAndW5rbm93bidgLCBidXRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdvdWxkIG11dGF0ZSBmdXR1cmUgY2FsbHMgd2l0aCB0aGlzIGNvbmZpZyBvYmplY3QuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMucmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikge1xuICAgICAgICAgICAgLy8gVGhlIERPTUV4Y2VwdGlvbidzIGVxdWl2YWxlbnQgdG8gY29kZSBpcyBpdHMgbmFtZVxuICAgICAgICAgICAgLy8gRS5nLjogbmFtZSA9IGBUaW1lb3V0RXJyb3JgLCBjb2RlID0gbnVtYmVyXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NRXhjZXB0aW9uL25hbWVcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IGNhdXNlLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2F1c2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYXVzZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdjb2RlJyBpbiBjYXVzZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBjYXVzZS5jb2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2F1c2UuY29kZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBjYXVzZS5jb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIEFJUC0xOTMgY29uZm9ybWluZyBlcnJvciBleHRyYWN0b3IuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dvb2dsZS5haXAuZGV2LzE5MyNodHRwMTFqc29uLXJlcHJlc2VudGF0aW9uIEFJUC0xOTN9XG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAZXhwaXJlbWVudGFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzIHRoZSByZXNwb25zZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgZXh0cmFjdGVkIGVycm9yIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGV4dHJhY3RBUElFcnJvckZyb21SZXNwb25zZShyZXMsIGRlZmF1bHRFcnJvck1lc3NhZ2UgPSAnVGhlIHJlcXVlc3QgZmFpbGVkJykge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGRlZmF1bHRFcnJvck1lc3NhZ2U7XG4gICAgICAgIC8vIFVzZSByZXMuZGF0YSBhcyB0aGUgZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAodHlwZW9mIHJlcy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHJlcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuZGF0YSAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlcy5kYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2Vycm9yJyBpbiByZXMuZGF0YSAmJlxuICAgICAgICAgICAgcmVzLmRhdGEuZXJyb3IgJiZcbiAgICAgICAgICAgICFyZXMub2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEuZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzLmRhdGEuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEuZXJyb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBzdGF0dXMgZnJvbSBkYXRhLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnIGluIHJlcy5kYXRhLmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzLmRhdGEuZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzLmRhdGEuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3Qgc3RhdHVzIGZyb20gZGF0YS5lcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9ICdzdGF0dXMnIGluIHJlcy5kYXRhLmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXMuZGF0YS5lcnJvci5zdGF0dXMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gcmVzLmRhdGEuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgIDogcmVzLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBjb2RlIGZyb20gZGF0YS5lcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAnY29kZScgaW4gcmVzLmRhdGEuZXJyb3IgJiYgdHlwZW9mIHJlcy5kYXRhLmVycm9yLmNvZGUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gcmVzLmRhdGEuZXJyb3IuY29kZVxuICAgICAgICAgICAgICAgICAgICA6IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKCdlcnJvcnMnIGluIHJlcy5kYXRhLmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocmVzLmRhdGEuZXJyb3IuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiByZXMuZGF0YS5lcnJvci5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZScgaW4gZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBlLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlcy5qb2luKCdcXG4nKSB8fCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzLmRhdGEuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICB9LCByZXMuZGF0YS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzVGV4dCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkdheGlvc0Vycm9yID0gR2F4aW9zRXJyb3I7XG5mdW5jdGlvbiB0cmFuc2xhdGVEYXRhKHJlc3BvbnNlVHlwZSwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCd1dGY4JykpO1xuICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEudGV4dCgpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXhwZXJpbWVudGFsIGVycm9yIHJlZGFjdG9yLlxuICpcbiAqIEBwYXJhbSBjb25maWcgQ29uZmlnIHRvIHBvdGVudGlhbGx5IHJlZGFjdCBwcm9wZXJ0aWVzIG9mXG4gKiBAcGFyYW0gcmVzcG9uc2UgQ29uZmlnIHRvIHBvdGVudGlhbGx5IHJlZGFjdCBwcm9wZXJ0aWVzIG9mXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JSZWRhY3RvcihkYXRhKSB7XG4gICAgY29uc3QgUkVEQUNUID0gJzw8UkVEQUNURUQ+IC0gU2VlIGBlcnJvclJlZGFjdG9yYCBvcHRpb24gaW4gYGdheGlvc2AgZm9yIGNvbmZpZ3VyYXRpb24+Lic7XG4gICAgZnVuY3Rpb24gcmVkYWN0SGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICghaGVhZGVycylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIGFueSBjYXNpbmcgb2YgYEF1dGhlbnRpY2F0aW9uYFxuICAgICAgICAgICAgLy8gYW55IGNhc2luZyBvZiBgQXV0aG9yaXphdGlvbmBcbiAgICAgICAgICAgIC8vIGFueXRoaW5nIGNvbnRhaW5pbmcgc2VjcmV0LCBzdWNoIGFzICdjbGllbnQgc2VjcmV0J1xuICAgICAgICAgICAgaWYgKC9eYXV0aGVudGljYXRpb24kL2kudGVzdChrZXkpIHx8XG4gICAgICAgICAgICAgICAgL15hdXRob3JpemF0aW9uJC9pLnRlc3Qoa2V5KSB8fFxuICAgICAgICAgICAgICAgIC9zZWNyZXQvaS50ZXN0KGtleSkpXG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoa2V5LCBSRURBQ1QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkYWN0U3RyaW5nKG9iaiwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAoL2dyYW50X3R5cGU9L2kudGVzdCh0ZXh0KSB8fFxuICAgICAgICAgICAgICAgIC9hc3NlcnRpb249L2kudGVzdCh0ZXh0KSB8fFxuICAgICAgICAgICAgICAgIC9zZWNyZXQvaS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBSRURBQ1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkYWN0T2JqZWN0KG9iaikge1xuICAgICAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8XG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgYG5vZGUtZmV0Y2hgIEZvcm1EYXRhL1VSTFNlYXJjaFBhcmFtc1xuICAgICAgICAgICAgKCdmb3JFYWNoJyBpbiBvYmogJiYgJ3NldCcgaW4gb2JqKSkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChbJ2dyYW50X3R5cGUnLCAnYXNzZXJ0aW9uJ10uaW5jbHVkZXMoa2V5KSB8fCAvc2VjcmV0Ly50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNldChrZXksIFJFREFDVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoJ2dyYW50X3R5cGUnIGluIG9iaikge1xuICAgICAgICAgICAgICAgIG9ialsnZ3JhbnRfdHlwZSddID0gUkVEQUNUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdhc3NlcnRpb24nIGluIG9iaikge1xuICAgICAgICAgICAgICAgIG9ialsnYXNzZXJ0aW9uJ10gPSBSRURBQ1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2NsaWVudF9zZWNyZXQnIGluIG9iaikge1xuICAgICAgICAgICAgICAgIG9ialsnY2xpZW50X3NlY3JldCddID0gUkVEQUNUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbmZpZykge1xuICAgICAgICByZWRhY3RIZWFkZXJzKGRhdGEuY29uZmlnLmhlYWRlcnMpO1xuICAgICAgICByZWRhY3RTdHJpbmcoZGF0YS5jb25maWcsICdkYXRhJyk7XG4gICAgICAgIHJlZGFjdE9iamVjdChkYXRhLmNvbmZpZy5kYXRhKTtcbiAgICAgICAgcmVkYWN0U3RyaW5nKGRhdGEuY29uZmlnLCAnYm9keScpO1xuICAgICAgICByZWRhY3RPYmplY3QoZGF0YS5jb25maWcuYm9keSk7XG4gICAgICAgIGlmIChkYXRhLmNvbmZpZy51cmwuc2VhcmNoUGFyYW1zLmhhcygndG9rZW4nKSkge1xuICAgICAgICAgICAgZGF0YS5jb25maWcudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Rva2VuJywgUkVEQUNUKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb25maWcudXJsLnNlYXJjaFBhcmFtcy5oYXMoJ2NsaWVudF9zZWNyZXQnKSkge1xuICAgICAgICAgICAgZGF0YS5jb25maWcudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NsaWVudF9zZWNyZXQnLCBSRURBQ1QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLnJlc3BvbnNlKSB7XG4gICAgICAgIGRlZmF1bHRFcnJvclJlZGFjdG9yKHsgY29uZmlnOiBkYXRhLnJlc3BvbnNlLmNvbmZpZyB9KTtcbiAgICAgICAgcmVkYWN0SGVhZGVycyhkYXRhLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBgbm9kZS1mZXRjaGAncyBgLmRhdGFgIGRlcHJlY2F0aW9uLi4uXG4gICAgICAgIGlmIChkYXRhLnJlc3BvbnNlLmJvZHlVc2VkKSB7XG4gICAgICAgICAgICByZWRhY3RTdHJpbmcoZGF0YS5yZXNwb25zZSwgJ2RhdGEnKTtcbiAgICAgICAgICAgIHJlZGFjdE9iamVjdChkYXRhLnJlc3BvbnNlLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJHYXhpb3NFcnJvciIsIkdBWElPU19FUlJPUl9TWU1CT0wiLCJkZWZhdWx0RXJyb3JSZWRhY3RvciIsImV4dGVuZF8xIiwicmVxdWlyZSIsInV0aWxfY2pzXzEiLCJwa2ciLCJkZWZhdWx0IiwiU3ltYm9sIiwiZm9yIiwibmFtZSIsIkVycm9yIiwiaGFzSW5zdGFuY2UiLCJpbnN0YW5jZSIsInZlcnNpb24iLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImNhbGwiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJjb25maWciLCJyZXNwb25zZSIsImNhdXNlIiwiZXJyb3IiLCJ1bmRlZmluZWQiLCJkYXRhIiwidHJhbnNsYXRlRGF0YSIsInJlc3BvbnNlVHlwZSIsImJvZHlVc2VkIiwic3RhdHVzIiwiRE9NRXhjZXB0aW9uIiwiY29kZSIsImV4dHJhY3RBUElFcnJvckZyb21SZXNwb25zZSIsInJlcyIsImRlZmF1bHRFcnJvck1lc3NhZ2UiLCJvayIsInN0YXR1c1RleHQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvcnMiLCJlcnJvck1lc3NhZ2VzIiwiZSIsInB1c2giLCJhc3NpZ24iLCJqb2luIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwidGV4dCIsIlJFREFDVCIsInJlZGFjdEhlYWRlcnMiLCJoZWFkZXJzIiwiZm9yRWFjaCIsIl8iLCJrZXkiLCJ0ZXN0Iiwic2V0IiwicmVkYWN0U3RyaW5nIiwib2JqIiwicmVkYWN0T2JqZWN0IiwiRm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJpbmNsdWRlcyIsImJvZHkiLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJoYXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/gaxios.js":
/*!*****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/gaxios.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Gaxios = void 0;\nconst extend_1 = __importDefault(__webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\"));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\nconst common_js_1 = __webpack_require__(/*! ./common.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/common.js\");\nconst retry_js_1 = __webpack_require__(/*! ./retry.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/retry.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst interceptor_js_1 = __webpack_require__(/*! ./interceptor.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js\");\nconst randomUUID = async ()=>globalThis.crypto?.randomUUID() || (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ \"crypto\", 23))).randomUUID();\nclass Gaxios {\n    /**\n     * The Gaxios class is responsible for making HTTP requests.\n     * @param defaults The default set of options to be used for this instance.\n     */ constructor(defaults){\n        this.agentCache = new Map();\n        this.defaults = defaults || {};\n        this.interceptors = {\n            request: new interceptor_js_1.GaxiosInterceptorManager(),\n            response: new interceptor_js_1.GaxiosInterceptorManager()\n        };\n    }\n    /**\n     * A {@link fetch `fetch`} compliant API for {@link Gaxios}.\n     *\n     * @remarks\n     *\n     * This is useful as a drop-in replacement for `fetch` API usage.\n     *\n     * @example\n     *\n     * ```ts\n     * const gaxios = new Gaxios();\n     * const myFetch: typeof fetch = (...args) => gaxios.fetch(...args);\n     * await myFetch('https://example.com');\n     * ```\n     *\n     * @param args `fetch` API or `Gaxios#request` parameters\n     * @returns the {@link Response} with Gaxios-added properties\n     */ fetch(...args) {\n        // Up to 2 parameters in either overload\n        const input = args[0];\n        const init = args[1];\n        let url = undefined;\n        const headers = new Headers();\n        // prepare URL\n        if (typeof input === \"string\") {\n            url = new URL(input);\n        } else if (input instanceof URL) {\n            url = input;\n        } else if (input && input.url) {\n            url = new URL(input.url);\n        }\n        // prepare headers\n        if (input && typeof input === \"object\" && \"headers\" in input) {\n            _a.mergeHeaders(headers, input.headers);\n        }\n        if (init) {\n            _a.mergeHeaders(headers, new Headers(init.headers));\n        }\n        // prepare request\n        if (typeof input === \"object\" && !(input instanceof URL)) {\n            // input must have been a non-URL object\n            return this.request({\n                ...init,\n                ...input,\n                headers,\n                url\n            });\n        } else {\n            // input must have been a string or URL\n            return this.request({\n                ...init,\n                headers,\n                url\n            });\n        }\n    }\n    /**\n     * Perform an HTTP request with the given options.\n     * @param opts Set of HTTP options that will be used for this HTTP request.\n     */ async request(opts = {}) {\n        let prepared = await this.#prepareRequest(opts);\n        prepared = await this.#applyRequestInterceptors(prepared);\n        return this.#applyResponseInterceptors(this._request(prepared));\n    }\n    async _defaultAdapter(config) {\n        const fetchImpl = config.fetchImplementation || this.defaults.fetchImplementation || await _a.#getFetch();\n        // node-fetch v3 warns when `data` is present\n        // https://github.com/node-fetch/node-fetch/issues/1000\n        const preparedOpts = {\n            ...config\n        };\n        delete preparedOpts.data;\n        const res = await fetchImpl(config.url, preparedOpts);\n        const data = await this.getResponseData(config, res);\n        if (!Object.getOwnPropertyDescriptor(res, \"data\")?.configurable) {\n            // Work-around for `node-fetch` v3 as accessing `data` would otherwise throw\n            Object.defineProperties(res, {\n                data: {\n                    configurable: true,\n                    writable: true,\n                    enumerable: true,\n                    value: data\n                }\n            });\n        }\n        // Keep object as an instance of `Response`\n        return Object.assign(res, {\n            config,\n            data\n        });\n    }\n    /**\n     * Internal, retryable version of the `request` method.\n     * @param opts Set of HTTP options that will be used for this HTTP request.\n     */ async _request(opts) {\n        try {\n            let translatedResponse;\n            if (opts.adapter) {\n                translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));\n            } else {\n                translatedResponse = await this._defaultAdapter(opts);\n            }\n            if (!opts.validateStatus(translatedResponse.status)) {\n                if (opts.responseType === \"stream\") {\n                    const response = [];\n                    for await (const chunk of opts.data ?? []){\n                        response.push(chunk);\n                    }\n                    translatedResponse.data = response;\n                }\n                const errorInfo = common_js_1.GaxiosError.extractAPIErrorFromResponse(translatedResponse, `Request failed with status code ${translatedResponse.status}`);\n                throw new common_js_1.GaxiosError(errorInfo?.message, opts, translatedResponse, errorInfo);\n            }\n            return translatedResponse;\n        } catch (e) {\n            let err;\n            if (e instanceof common_js_1.GaxiosError) {\n                err = e;\n            } else if (e instanceof Error) {\n                err = new common_js_1.GaxiosError(e.message, opts, undefined, e);\n            } else {\n                err = new common_js_1.GaxiosError(\"Unexpected Gaxios Error\", opts, undefined, e);\n            }\n            const { shouldRetry, config } = await (0, retry_js_1.getRetryConfig)(err);\n            if (shouldRetry && config) {\n                err.config.retryConfig.currentRetryAttempt = config.retryConfig.currentRetryAttempt;\n                // The error's config could be redacted - therefore we only want to\n                // copy the retry state over to the existing config\n                opts.retryConfig = err.config?.retryConfig;\n                // re-prepare timeout for the next request\n                this.#appendTimeoutToSignal(opts);\n                return this._request(opts);\n            }\n            if (opts.errorRedactor) {\n                opts.errorRedactor(err);\n            }\n            throw err;\n        }\n    }\n    async getResponseData(opts, res) {\n        if (opts.maxContentLength && res.headers.has(\"content-length\") && opts.maxContentLength < Number.parseInt(res.headers?.get(\"content-length\") || \"\")) {\n            throw new common_js_1.GaxiosError(\"Response's `Content-Length` is over the limit.\", opts, Object.assign(res, {\n                config: opts\n            }));\n        }\n        switch(opts.responseType){\n            case \"stream\":\n                return res.body;\n            case \"json\":\n                return res.json();\n            case \"arraybuffer\":\n                return res.arrayBuffer();\n            case \"blob\":\n                return res.blob();\n            case \"text\":\n                return res.text();\n            default:\n                return this.getResponseDataFromContentType(res);\n        }\n    }\n    #urlMayUseProxy(url, noProxy = []) {\n        const candidate = new URL(url);\n        const noProxyList = [\n            ...noProxy\n        ];\n        const noProxyEnvList = (process.env.NO_PROXY ?? process.env.no_proxy)?.split(\",\") || [];\n        for (const rule of noProxyEnvList){\n            noProxyList.push(rule.trim());\n        }\n        for (const rule of noProxyList){\n            // Match regex\n            if (rule instanceof RegExp) {\n                if (rule.test(candidate.toString())) {\n                    return false;\n                }\n            } else if (rule instanceof URL) {\n                if (rule.origin === candidate.origin) {\n                    return false;\n                }\n            } else if (rule.startsWith(\"*.\") || rule.startsWith(\".\")) {\n                const cleanedRule = rule.replace(/^\\*\\./, \".\");\n                if (candidate.hostname.endsWith(cleanedRule)) {\n                    return false;\n                }\n            } else if (rule === candidate.origin || rule === candidate.hostname || rule === candidate.href) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Applies the request interceptors. The request interceptors are applied after the\n     * call to prepareRequest is completed.\n     *\n     * @param {GaxiosOptionsPrepared} options The current set of options.\n     *\n     * @returns {Promise<GaxiosOptionsPrepared>} Promise that resolves to the set of options or response after interceptors are applied.\n     */ async #applyRequestInterceptors(options) {\n        let promiseChain = Promise.resolve(options);\n        for (const interceptor of this.interceptors.request.values()){\n            if (interceptor) {\n                promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);\n            }\n        }\n        return promiseChain;\n    }\n    /**\n     * Applies the response interceptors. The response interceptors are applied after the\n     * call to request is made.\n     *\n     * @param {GaxiosOptionsPrepared} options The current set of options.\n     *\n     * @returns {Promise<GaxiosOptionsPrepared>} Promise that resolves to the set of options or response after interceptors are applied.\n     */ async #applyResponseInterceptors(response) {\n        let promiseChain = Promise.resolve(response);\n        for (const interceptor of this.interceptors.response.values()){\n            if (interceptor) {\n                promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);\n            }\n        }\n        return promiseChain;\n    }\n    /**\n     * Validates the options, merges them with defaults, and prepare request.\n     *\n     * @param options The original options passed from the client.\n     * @returns Prepared options, ready to make a request\n     */ async #prepareRequest(options) {\n        // Prepare Headers - copy in order to not mutate the original objects\n        const preparedHeaders = new Headers(this.defaults.headers);\n        _a.mergeHeaders(preparedHeaders, options.headers);\n        // Merge options\n        const opts = (0, extend_1.default)(true, {}, this.defaults, options);\n        if (!opts.url) {\n            throw new Error(\"URL is required.\");\n        }\n        if (opts.baseURL) {\n            opts.url = new URL(opts.url, opts.baseURL);\n        }\n        // don't modify the properties of a default or provided URL\n        opts.url = new URL(opts.url);\n        if (opts.params) {\n            if (opts.paramsSerializer) {\n                let additionalQueryParams = opts.paramsSerializer(opts.params);\n                if (additionalQueryParams.startsWith(\"?\")) {\n                    additionalQueryParams = additionalQueryParams.slice(1);\n                }\n                const prefix = opts.url.toString().includes(\"?\") ? \"&\" : \"?\";\n                opts.url = opts.url + prefix + additionalQueryParams;\n            } else {\n                const url = opts.url instanceof URL ? opts.url : new URL(opts.url);\n                for (const [key, value] of new URLSearchParams(opts.params)){\n                    url.searchParams.append(key, value);\n                }\n                opts.url = url;\n            }\n        }\n        if (typeof options.maxContentLength === \"number\") {\n            opts.size = options.maxContentLength;\n        }\n        if (typeof options.maxRedirects === \"number\") {\n            opts.follow = options.maxRedirects;\n        }\n        const shouldDirectlyPassData = typeof opts.data === \"string\" || opts.data instanceof ArrayBuffer || opts.data instanceof Blob || // Node 18 does not have a global `File` object\n        globalThis.File && opts.data instanceof File || opts.data instanceof FormData || opts.data instanceof stream_1.Readable || opts.data instanceof ReadableStream || opts.data instanceof String || opts.data instanceof URLSearchParams || ArrayBuffer.isView(opts.data) || // `Buffer` (Node.js), `DataView`, `TypedArray`\n        /**\n             * @deprecated `node-fetch` or another third-party's request types\n             */ [\n            \"Blob\",\n            \"File\",\n            \"FormData\"\n        ].includes(opts.data?.constructor?.name || \"\");\n        if (opts.multipart?.length) {\n            const boundary = await randomUUID();\n            preparedHeaders.set(\"content-type\", `multipart/related; boundary=${boundary}`);\n            opts.body = stream_1.Readable.from(this.getMultipartRequest(opts.multipart, boundary));\n        } else if (shouldDirectlyPassData) {\n            opts.body = opts.data;\n        } else if (typeof opts.data === \"object\") {\n            if (preparedHeaders.get(\"Content-Type\") === \"application/x-www-form-urlencoded\") {\n                // If www-form-urlencoded content type has been set, but data is\n                // provided as an object, serialize the content\n                opts.body = opts.paramsSerializer ? opts.paramsSerializer(opts.data) : new URLSearchParams(opts.data);\n            } else {\n                if (!preparedHeaders.has(\"content-type\")) {\n                    preparedHeaders.set(\"content-type\", \"application/json\");\n                }\n                opts.body = JSON.stringify(opts.data);\n            }\n        } else if (opts.data) {\n            opts.body = opts.data;\n        }\n        opts.validateStatus = opts.validateStatus || this.validateStatus;\n        opts.responseType = opts.responseType || \"unknown\";\n        if (!preparedHeaders.has(\"accept\") && opts.responseType === \"json\") {\n            preparedHeaders.set(\"accept\", \"application/json\");\n        }\n        const proxy = opts.proxy || process?.env?.HTTPS_PROXY || process?.env?.https_proxy || process?.env?.HTTP_PROXY || process?.env?.http_proxy;\n        if (opts.agent) {\n        // don't do any of the following options - use the user-provided agent.\n        } else if (proxy && this.#urlMayUseProxy(opts.url, opts.noProxy)) {\n            const HttpsProxyAgent = await _a.#getProxyAgent();\n            if (this.agentCache.has(proxy)) {\n                opts.agent = this.agentCache.get(proxy);\n            } else {\n                opts.agent = new HttpsProxyAgent(proxy, {\n                    cert: opts.cert,\n                    key: opts.key\n                });\n                this.agentCache.set(proxy, opts.agent);\n            }\n        } else if (opts.cert && opts.key) {\n            // Configure client for mTLS\n            if (this.agentCache.has(opts.key)) {\n                opts.agent = this.agentCache.get(opts.key);\n            } else {\n                opts.agent = new https_1.Agent({\n                    cert: opts.cert,\n                    key: opts.key\n                });\n                this.agentCache.set(opts.key, opts.agent);\n            }\n        }\n        if (typeof opts.errorRedactor !== \"function\" && opts.errorRedactor !== false) {\n            opts.errorRedactor = common_js_1.defaultErrorRedactor;\n        }\n        if (opts.body && !(\"duplex\" in opts)) {\n            /**\n             * required for Node.js and the type isn't available today\n             * @link https://github.com/nodejs/node/issues/46221\n             * @link https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1483\n             */ opts.duplex = \"half\";\n        }\n        this.#appendTimeoutToSignal(opts);\n        return Object.assign(opts, {\n            headers: preparedHeaders,\n            url: opts.url instanceof URL ? opts.url : new URL(opts.url)\n        });\n    }\n    #appendTimeoutToSignal(opts) {\n        if (opts.timeout) {\n            const timeoutSignal = AbortSignal.timeout(opts.timeout);\n            if (opts.signal && !opts.signal.aborted) {\n                opts.signal = AbortSignal.any([\n                    opts.signal,\n                    timeoutSignal\n                ]);\n            } else {\n                opts.signal = timeoutSignal;\n            }\n        }\n    }\n    /**\n     * By default, throw for any non-2xx status code\n     * @param status status code from the HTTP response\n     */ validateStatus(status) {\n        return status >= 200 && status < 300;\n    }\n    /**\n     * Attempts to parse a response by looking at the Content-Type header.\n     * @param {Response} response the HTTP response.\n     * @returns a promise that resolves to the response data.\n     */ async getResponseDataFromContentType(response) {\n        let contentType = response.headers.get(\"Content-Type\");\n        if (contentType === null) {\n            // Maintain existing functionality by calling text()\n            return response.text();\n        }\n        contentType = contentType.toLowerCase();\n        if (contentType.includes(\"application/json\")) {\n            let data = await response.text();\n            try {\n                data = JSON.parse(data);\n            } catch  {\n            // continue\n            }\n            return data;\n        } else if (contentType.match(/^text\\//)) {\n            return response.text();\n        } else {\n            // If the content type is something not easily handled, just return the raw data (blob)\n            return response.blob();\n        }\n    }\n    /**\n     * Creates an async generator that yields the pieces of a multipart/related request body.\n     * This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive\n     * multipart/related requests are not currently supported.\n     *\n     * @param {GaxioMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.\n     * @param {string} boundary the boundary string to be placed between each part.\n     */ async *getMultipartRequest(multipartOptions, boundary) {\n        const finale = `--${boundary}--`;\n        for (const currentPart of multipartOptions){\n            const partContentType = currentPart.headers.get(\"Content-Type\") || \"application/octet-stream\";\n            const preamble = `--${boundary}\\r\\nContent-Type: ${partContentType}\\r\\n\\r\\n`;\n            yield preamble;\n            if (typeof currentPart.content === \"string\") {\n                yield currentPart.content;\n            } else {\n                yield* currentPart.content;\n            }\n            yield \"\\r\\n\";\n        }\n        yield finale;\n    }\n    /**\n     * A cache for the lazily-loaded proxy agent.\n     *\n     * Should use {@link Gaxios[#getProxyAgent]} to retrieve.\n     */ // using `import` to dynamically import the types here\n    static #proxyAgent;\n    /**\n     * A cache for the lazily-loaded fetch library.\n     *\n     * Should use {@link Gaxios[#getFetch]} to retrieve.\n     */ //\n    static #fetch;\n    /**\n     * Imports, caches, and returns a proxy agent - if not already imported\n     *\n     * @returns A proxy agent\n     */ static async #getProxyAgent() {\n        this.#proxyAgent ||= (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/gaxios\"), __webpack_require__.e(\"vendor-chunks/debug\"), __webpack_require__.e(\"vendor-chunks/supports-color\"), __webpack_require__.e(\"vendor-chunks/has-flag\")]).then(__webpack_require__.bind(__webpack_require__, /*! https-proxy-agent */ \"(rsc)/./node_modules/gaxios/node_modules/https-proxy-agent/dist/index.js\"))).HttpsProxyAgent;\n        return this.#proxyAgent;\n    }\n    static async #getFetch() {\n        const hasWindow =  false && 0;\n        this.#fetch ||= hasWindow ? window.fetch : (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/fetch-blob\"), __webpack_require__.e(\"vendor-chunks/formdata-polyfill\"), __webpack_require__.e(\"vendor-chunks/data-uri-to-buffer\"), __webpack_require__.e(\"vendor-chunks/web-streams-polyfill\"), __webpack_require__.e(\"vendor-chunks/node-domexception\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(rsc)/./node_modules/node-fetch/src/index.js\"))).default;\n        return this.#fetch;\n    }\n    /**\n     * Merges headers.\n     * If the base headers do not exist a new `Headers` object will be returned.\n     *\n     * @remarks\n     *\n     * Using this utility can be helpful when the headers are not known to exist:\n     * - if they exist as `Headers`, that instance will be used\n     *   - it improves performance and allows users to use their existing references to their `Headers`\n     * - if they exist in another form (`HeadersInit`), they will be used to create a new `Headers` object\n     * - if the base headers do not exist a new `Headers` object will be created\n     *\n     * @param base headers to append/overwrite to\n     * @param append headers to append/overwrite with\n     * @returns the base headers instance with merged `Headers`\n     */ static mergeHeaders(base, ...append) {\n        base = base instanceof Headers ? base : new Headers(base);\n        for (const headers of append){\n            const add = headers instanceof Headers ? headers : new Headers(headers);\n            add.forEach((value, key)=>{\n                // set-cookie is the only header that would repeat.\n                // A bit of background: https://developer.mozilla.org/en-US/docs/Web/API/Headers/getSetCookie\n                key === \"set-cookie\" ? base.append(key, value) : base.set(key, value);\n            });\n        }\n        return base;\n    }\n}\nexports.Gaxios = Gaxios;\n_a = Gaxios; //# sourceMappingURL=gaxios.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvZ2F4aW9zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixnREFBZ0Q7QUFDaEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0EsSUFBSUU7QUFDSkMsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLE1BQU1HLFdBQVdULGdCQUFnQlUsbUJBQU9BLENBQUMsb0RBQVE7QUFDakQsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsb0JBQU87QUFDL0IsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsd0VBQWE7QUFDekMsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsc0VBQVk7QUFDdkMsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUssbUJBQW1CTCxtQkFBT0EsQ0FBQyxrRkFBa0I7QUFDbkQsTUFBTU0sYUFBYSxVQUFZQyxXQUFXQyxNQUFNLEVBQUVGLGdCQUFnQixDQUFDLE1BQU0sa0hBQWUsRUFBR0EsVUFBVTtBQUNyRyxNQUFNUjtJQVVGOzs7S0FHQyxHQUNEVyxZQUFZQyxRQUFRLENBQUU7YUFidEJDLGFBQWEsSUFBSUM7UUFjYixJQUFJLENBQUNGLFFBQVEsR0FBR0EsWUFBWSxDQUFDO1FBQzdCLElBQUksQ0FBQ0csWUFBWSxHQUFHO1lBQ2hCQyxTQUFTLElBQUlULGlCQUFpQlUsd0JBQXdC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QUFDSjtBQUNBcEwsY0FBYyxHQUFHRTtBQUNqQkwsS0FBS0ssUUFDTCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5rLXNhdmVyLWF1dG8tc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9nYXhpb3MvYnVpbGQvY2pzL3NyYy9nYXhpb3MuanM/Y2M3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HYXhpb3MgPSB2b2lkIDA7XG5jb25zdCBleHRlbmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXh0ZW5kXCIpKTtcbmNvbnN0IGh0dHBzXzEgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5jb25zdCBjb21tb25fanNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcbmNvbnN0IHJldHJ5X2pzXzEgPSByZXF1aXJlKFwiLi9yZXRyeS5qc1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGludGVyY2VwdG9yX2pzXzEgPSByZXF1aXJlKFwiLi9pbnRlcmNlcHRvci5qc1wiKTtcbmNvbnN0IHJhbmRvbVVVSUQgPSBhc3luYyAoKSA9PiBnbG9iYWxUaGlzLmNyeXB0bz8ucmFuZG9tVVVJRCgpIHx8IChhd2FpdCBpbXBvcnQoJ2NyeXB0bycpKS5yYW5kb21VVUlEKCk7XG5jbGFzcyBHYXhpb3Mge1xuICAgIGFnZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBIVFRQIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGV2ZXJ5IEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBkZWZhdWx0cztcbiAgICAvKipcbiAgICAgKiBJbnRlcmNlcHRvcnNcbiAgICAgKi9cbiAgICBpbnRlcmNlcHRvcnM7XG4gICAgLyoqXG4gICAgICogVGhlIEdheGlvcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIEhUVFAgcmVxdWVzdHMuXG4gICAgICogQHBhcmFtIGRlZmF1bHRzIFRoZSBkZWZhdWx0IHNldCBvZiBvcHRpb25zIHRvIGJlIHVzZWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzIHx8IHt9O1xuICAgICAgICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IG5ldyBpbnRlcmNlcHRvcl9qc18xLkdheGlvc0ludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgICAgICAgICAgcmVzcG9uc2U6IG5ldyBpbnRlcmNlcHRvcl9qc18xLkdheGlvc0ludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHtAbGluayBmZXRjaCBgZmV0Y2hgfSBjb21wbGlhbnQgQVBJIGZvciB7QGxpbmsgR2F4aW9zfS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBhcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIGBmZXRjaGAgQVBJIHVzYWdlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgZ2F4aW9zID0gbmV3IEdheGlvcygpO1xuICAgICAqIGNvbnN0IG15RmV0Y2g6IHR5cGVvZiBmZXRjaCA9ICguLi5hcmdzKSA9PiBnYXhpb3MuZmV0Y2goLi4uYXJncyk7XG4gICAgICogYXdhaXQgbXlGZXRjaCgnaHR0cHM6Ly9leGFtcGxlLmNvbScpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgYGZldGNoYCBBUEkgb3IgYEdheGlvcyNyZXF1ZXN0YCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgdGhlIHtAbGluayBSZXNwb25zZX0gd2l0aCBHYXhpb3MtYWRkZWQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVXAgdG8gMiBwYXJhbWV0ZXJzIGluIGVpdGhlciBvdmVybG9hZFxuICAgICAgICBjb25zdCBpbnB1dCA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IGluaXQgPSBhcmdzWzFdO1xuICAgICAgICBsZXQgdXJsID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgLy8gcHJlcGFyZSBVUkxcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHVybCA9IG5ldyBVUkwoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICB1cmwgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dCAmJiBpbnB1dC51cmwpIHtcbiAgICAgICAgICAgIHVybCA9IG5ldyBVUkwoaW5wdXQudXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVwYXJlIGhlYWRlcnNcbiAgICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgJ2hlYWRlcnMnIGluIGlucHV0KSB7XG4gICAgICAgICAgICBfYS5tZXJnZUhlYWRlcnMoaGVhZGVycywgaW5wdXQuaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIF9hLm1lcmdlSGVhZGVycyhoZWFkZXJzLCBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVwYXJlIHJlcXVlc3RcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgIShpbnB1dCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgICAgIC8vIGlucHV0IG11c3QgaGF2ZSBiZWVuIGEgbm9uLVVSTCBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyAuLi5pbml0LCAuLi5pbnB1dCwgaGVhZGVycywgdXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5wdXQgbXVzdCBoYXZlIGJlZW4gYSBzdHJpbmcgb3IgVVJMXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgLi4uaW5pdCwgaGVhZGVycywgdXJsIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdHMgU2V0IG9mIEhUVFAgb3B0aW9ucyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhpcyBIVFRQIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdChvcHRzID0ge30pIHtcbiAgICAgICAgbGV0IHByZXBhcmVkID0gYXdhaXQgdGhpcy4jcHJlcGFyZVJlcXVlc3Qob3B0cyk7XG4gICAgICAgIHByZXBhcmVkID0gYXdhaXQgdGhpcy4jYXBwbHlSZXF1ZXN0SW50ZXJjZXB0b3JzKHByZXBhcmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5UmVzcG9uc2VJbnRlcmNlcHRvcnModGhpcy5fcmVxdWVzdChwcmVwYXJlZCkpO1xuICAgIH1cbiAgICBhc3luYyBfZGVmYXVsdEFkYXB0ZXIoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGZldGNoSW1wbCA9IGNvbmZpZy5mZXRjaEltcGxlbWVudGF0aW9uIHx8XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzLmZldGNoSW1wbGVtZW50YXRpb24gfHxcbiAgICAgICAgICAgIChhd2FpdCBfYS4jZ2V0RmV0Y2goKSk7XG4gICAgICAgIC8vIG5vZGUtZmV0Y2ggdjMgd2FybnMgd2hlbiBgZGF0YWAgaXMgcHJlc2VudFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwXG4gICAgICAgIGNvbnN0IHByZXBhcmVkT3B0cyA9IHsgLi4uY29uZmlnIH07XG4gICAgICAgIGRlbGV0ZSBwcmVwYXJlZE9wdHMuZGF0YTtcbiAgICAgICAgY29uc3QgcmVzID0gKGF3YWl0IGZldGNoSW1wbChjb25maWcudXJsLCBwcmVwYXJlZE9wdHMpKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0UmVzcG9uc2VEYXRhKGNvbmZpZywgcmVzKTtcbiAgICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlcywgJ2RhdGEnKT8uY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAvLyBXb3JrLWFyb3VuZCBmb3IgYG5vZGUtZmV0Y2hgIHYzIGFzIGFjY2Vzc2luZyBgZGF0YWAgd291bGQgb3RoZXJ3aXNlIHRocm93XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZXMsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBLZWVwIG9iamVjdCBhcyBhbiBpbnN0YW5jZSBvZiBgUmVzcG9uc2VgXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlcywgeyBjb25maWcsIGRhdGEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsLCByZXRyeWFibGUgdmVyc2lvbiBvZiB0aGUgYHJlcXVlc3RgIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gb3B0cyBTZXQgb2YgSFRUUCBvcHRpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGlzIEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVxdWVzdChvcHRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdHJhbnNsYXRlZFJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKG9wdHMuYWRhcHRlcikge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRSZXNwb25zZSA9IGF3YWl0IG9wdHMuYWRhcHRlcihvcHRzLCB0aGlzLl9kZWZhdWx0QWRhcHRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2RlZmF1bHRBZGFwdGVyKG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlU3RhdHVzKHRyYW5zbGF0ZWRSZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIChvcHRzLmRhdGEgPz8gW10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkUmVzcG9uc2UuZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckluZm8gPSBjb21tb25fanNfMS5HYXhpb3NFcnJvci5leHRyYWN0QVBJRXJyb3JGcm9tUmVzcG9uc2UodHJhbnNsYXRlZFJlc3BvbnNlLCBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke3RyYW5zbGF0ZWRSZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvbW1vbl9qc18xLkdheGlvc0Vycm9yKGVycm9ySW5mbz8ubWVzc2FnZSwgb3B0cywgdHJhbnNsYXRlZFJlc3BvbnNlLCBlcnJvckluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWRSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgY29tbW9uX2pzXzEuR2F4aW9zRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IGNvbW1vbl9qc18xLkdheGlvc0Vycm9yKGUubWVzc2FnZSwgb3B0cywgdW5kZWZpbmVkLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBjb21tb25fanNfMS5HYXhpb3NFcnJvcignVW5leHBlY3RlZCBHYXhpb3MgRXJyb3InLCBvcHRzLCB1bmRlZmluZWQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzaG91bGRSZXRyeSwgY29uZmlnIH0gPSBhd2FpdCAoMCwgcmV0cnlfanNfMS5nZXRSZXRyeUNvbmZpZykoZXJyKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXRyeSAmJiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBlcnIuY29uZmlnLnJldHJ5Q29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgPVxuICAgICAgICAgICAgICAgICAgICBjb25maWcucmV0cnlDb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IncyBjb25maWcgY291bGQgYmUgcmVkYWN0ZWQgLSB0aGVyZWZvcmUgd2Ugb25seSB3YW50IHRvXG4gICAgICAgICAgICAgICAgLy8gY29weSB0aGUgcmV0cnkgc3RhdGUgb3ZlciB0byB0aGUgZXhpc3RpbmcgY29uZmlnXG4gICAgICAgICAgICAgICAgb3B0cy5yZXRyeUNvbmZpZyA9IGVyci5jb25maWc/LnJldHJ5Q29uZmlnO1xuICAgICAgICAgICAgICAgIC8vIHJlLXByZXBhcmUgdGltZW91dCBmb3IgdGhlIG5leHQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHRoaXMuI2FwcGVuZFRpbWVvdXRUb1NpZ25hbChvcHRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmVycm9yUmVkYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmVycm9yUmVkYWN0b3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSZXNwb25zZURhdGEob3B0cywgcmVzKSB7XG4gICAgICAgIGlmIChvcHRzLm1heENvbnRlbnRMZW5ndGggJiZcbiAgICAgICAgICAgIHJlcy5oZWFkZXJzLmhhcygnY29udGVudC1sZW5ndGgnKSAmJlxuICAgICAgICAgICAgb3B0cy5tYXhDb250ZW50TGVuZ3RoIDxcbiAgICAgICAgICAgICAgICBOdW1iZXIucGFyc2VJbnQocmVzLmhlYWRlcnM/LmdldCgnY29udGVudC1sZW5ndGgnKSB8fCAnJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fanNfMS5HYXhpb3NFcnJvcihcIlJlc3BvbnNlJ3MgYENvbnRlbnQtTGVuZ3RoYCBpcyBvdmVyIHRoZSBsaW1pdC5cIiwgb3B0cywgT2JqZWN0LmFzc2lnbihyZXMsIHsgY29uZmlnOiBvcHRzIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wdHMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJlYW0nOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYm9keTtcbiAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYmxvYigpO1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlc3BvbnNlRGF0YUZyb21Db250ZW50VHlwZShyZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgICN1cmxNYXlVc2VQcm94eSh1cmwsIG5vUHJveHkgPSBbXSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIGNvbnN0IG5vUHJveHlMaXN0ID0gWy4uLm5vUHJveHldO1xuICAgICAgICBjb25zdCBub1Byb3h5RW52TGlzdCA9IChwcm9jZXNzLmVudi5OT19QUk9YWSA/PyBwcm9jZXNzLmVudi5ub19wcm94eSk/LnNwbGl0KCcsJykgfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBub1Byb3h5RW52TGlzdCkge1xuICAgICAgICAgICAgbm9Qcm94eUxpc3QucHVzaChydWxlLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIG5vUHJveHlMaXN0KSB7XG4gICAgICAgICAgICAvLyBNYXRjaCByZWdleFxuICAgICAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS50ZXN0KGNhbmRpZGF0ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWF0Y2ggVVJMXG4gICAgICAgICAgICBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUub3JpZ2luID09PSBjYW5kaWRhdGUub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXRjaCBzdHJpbmcgcmVnZXhcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc3RhcnRzV2l0aCgnKi4nKSB8fCBydWxlLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRSdWxlID0gcnVsZS5yZXBsYWNlKC9eXFwqXFwuLywgJy4nKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmhvc3RuYW1lLmVuZHNXaXRoKGNsZWFuZWRSdWxlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmFzaWMgc3RyaW5nIG1hdGNoXG4gICAgICAgICAgICBlbHNlIGlmIChydWxlID09PSBjYW5kaWRhdGUub3JpZ2luIHx8XG4gICAgICAgICAgICAgICAgcnVsZSA9PT0gY2FuZGlkYXRlLmhvc3RuYW1lIHx8XG4gICAgICAgICAgICAgICAgcnVsZSA9PT0gY2FuZGlkYXRlLmhyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHJlcXVlc3QgaW50ZXJjZXB0b3JzLiBUaGUgcmVxdWVzdCBpbnRlcmNlcHRvcnMgYXJlIGFwcGxpZWQgYWZ0ZXIgdGhlXG4gICAgICogY2FsbCB0byBwcmVwYXJlUmVxdWVzdCBpcyBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dheGlvc09wdGlvbnNQcmVwYXJlZH0gb3B0aW9ucyBUaGUgY3VycmVudCBzZXQgb2Ygb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdheGlvc09wdGlvbnNQcmVwYXJlZD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2V0IG9mIG9wdGlvbnMgb3IgcmVzcG9uc2UgYWZ0ZXIgaW50ZXJjZXB0b3JzIGFyZSBhcHBsaWVkLlxuICAgICAqL1xuICAgIGFzeW5jICNhcHBseVJlcXVlc3RJbnRlcmNlcHRvcnMob3B0aW9ucykge1xuICAgICAgICBsZXQgcHJvbWlzZUNoYWluID0gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGludGVyY2VwdG9yIG9mIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcmNlcHRvcikge1xuICAgICAgICAgICAgICAgIHByb21pc2VDaGFpbiA9IHByb21pc2VDaGFpbi50aGVuKGludGVyY2VwdG9yLnJlc29sdmVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2VDaGFpbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgcmVzcG9uc2UgaW50ZXJjZXB0b3JzLiBUaGUgcmVzcG9uc2UgaW50ZXJjZXB0b3JzIGFyZSBhcHBsaWVkIGFmdGVyIHRoZVxuICAgICAqIGNhbGwgdG8gcmVxdWVzdCBpcyBtYWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtHYXhpb3NPcHRpb25zUHJlcGFyZWR9IG9wdGlvbnMgVGhlIGN1cnJlbnQgc2V0IG9mIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHYXhpb3NPcHRpb25zUHJlcGFyZWQ+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNldCBvZiBvcHRpb25zIG9yIHJlc3BvbnNlIGFmdGVyIGludGVyY2VwdG9ycyBhcmUgYXBwbGllZC5cbiAgICAgKi9cbiAgICBhc3luYyAjYXBwbHlSZXNwb25zZUludGVyY2VwdG9ycyhyZXNwb25zZSkge1xuICAgICAgICBsZXQgcHJvbWlzZUNoYWluID0gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKGludGVyY2VwdG9yKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUNoYWluID0gcHJvbWlzZUNoYWluLnRoZW4oaW50ZXJjZXB0b3IucmVzb2x2ZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZUNoYWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIG9wdGlvbnMsIG1lcmdlcyB0aGVtIHdpdGggZGVmYXVsdHMsIGFuZCBwcmVwYXJlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3JpZ2luYWwgb3B0aW9ucyBwYXNzZWQgZnJvbSB0aGUgY2xpZW50LlxuICAgICAqIEByZXR1cm5zIFByZXBhcmVkIG9wdGlvbnMsIHJlYWR5IHRvIG1ha2UgYSByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgI3ByZXBhcmVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gUHJlcGFyZSBIZWFkZXJzIC0gY29weSBpbiBvcmRlciB0byBub3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBvYmplY3RzXG4gICAgICAgIGNvbnN0IHByZXBhcmVkSGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuZGVmYXVsdHMuaGVhZGVycyk7XG4gICAgICAgIF9hLm1lcmdlSGVhZGVycyhwcmVwYXJlZEhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIC8vIE1lcmdlIG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0cyA9ICgwLCBleHRlbmRfMS5kZWZhdWx0KSh0cnVlLCB7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghb3B0cy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmJhc2VVUkwpIHtcbiAgICAgICAgICAgIG9wdHMudXJsID0gbmV3IFVSTChvcHRzLnVybCwgb3B0cy5iYXNlVVJMKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb24ndCBtb2RpZnkgdGhlIHByb3BlcnRpZXMgb2YgYSBkZWZhdWx0IG9yIHByb3ZpZGVkIFVSTFxuICAgICAgICBvcHRzLnVybCA9IG5ldyBVUkwob3B0cy51cmwpO1xuICAgICAgICBpZiAob3B0cy5wYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zID0gb3B0cy5wYXJhbXNTZXJpYWxpemVyKG9wdHMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbFF1ZXJ5UGFyYW1zLnN0YXJ0c1dpdGgoJz8nKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUXVlcnlQYXJhbXMgPSBhZGRpdGlvbmFsUXVlcnlQYXJhbXMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdHMudXJsLnRvU3RyaW5nKCkuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgICAgICAgICAgICAgICBvcHRzLnVybCA9IG9wdHMudXJsICsgcHJlZml4ICsgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gb3B0cy51cmwgaW5zdGFuY2VvZiBVUkwgPyBvcHRzLnVybCA6IG5ldyBVUkwob3B0cy51cmwpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnVybCA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4Q29udGVudExlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9wdHMuc2l6ZSA9IG9wdGlvbnMubWF4Q29udGVudExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4UmVkaXJlY3RzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3B0cy5mb2xsb3cgPSBvcHRpb25zLm1heFJlZGlyZWN0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGREaXJlY3RseVBhc3NEYXRhID0gdHlwZW9mIG9wdHMuZGF0YSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIG9wdHMuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICBvcHRzLmRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8XG4gICAgICAgICAgICAvLyBOb2RlIDE4IGRvZXMgbm90IGhhdmUgYSBnbG9iYWwgYEZpbGVgIG9iamVjdFxuICAgICAgICAgICAgKGdsb2JhbFRoaXMuRmlsZSAmJiBvcHRzLmRhdGEgaW5zdGFuY2VvZiBGaWxlKSB8fFxuICAgICAgICAgICAgb3B0cy5kYXRhIGluc3RhbmNlb2YgRm9ybURhdGEgfHxcbiAgICAgICAgICAgIG9wdHMuZGF0YSBpbnN0YW5jZW9mIHN0cmVhbV8xLlJlYWRhYmxlIHx8XG4gICAgICAgICAgICBvcHRzLmRhdGEgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fFxuICAgICAgICAgICAgb3B0cy5kYXRhIGluc3RhbmNlb2YgU3RyaW5nIHx8XG4gICAgICAgICAgICBvcHRzLmRhdGEgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgIEFycmF5QnVmZmVyLmlzVmlldyhvcHRzLmRhdGEpIHx8IC8vIGBCdWZmZXJgIChOb2RlLmpzKSwgYERhdGFWaWV3YCwgYFR5cGVkQXJyYXlgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIGBub2RlLWZldGNoYCBvciBhbm90aGVyIHRoaXJkLXBhcnR5J3MgcmVxdWVzdCB0eXBlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBbJ0Jsb2InLCAnRmlsZScsICdGb3JtRGF0YSddLmluY2x1ZGVzKG9wdHMuZGF0YT8uY29uc3RydWN0b3I/Lm5hbWUgfHwgJycpO1xuICAgICAgICBpZiAob3B0cy5tdWx0aXBhcnQ/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYm91bmRhcnkgPSBhd2FpdCByYW5kb21VVUlEKCk7XG4gICAgICAgICAgICBwcmVwYXJlZEhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCBgbXVsdGlwYXJ0L3JlbGF0ZWQ7IGJvdW5kYXJ5PSR7Ym91bmRhcnl9YCk7XG4gICAgICAgICAgICBvcHRzLmJvZHkgPSBzdHJlYW1fMS5SZWFkYWJsZS5mcm9tKHRoaXMuZ2V0TXVsdGlwYXJ0UmVxdWVzdChvcHRzLm11bHRpcGFydCwgYm91bmRhcnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGREaXJlY3RseVBhc3NEYXRhKSB7XG4gICAgICAgICAgICBvcHRzLmJvZHkgPSBvcHRzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZEhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSA9PT1cbiAgICAgICAgICAgICAgICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHd3dy1mb3JtLXVybGVuY29kZWQgY29udGVudCB0eXBlIGhhcyBiZWVuIHNldCwgYnV0IGRhdGEgaXNcbiAgICAgICAgICAgICAgICAvLyBwcm92aWRlZCBhcyBhbiBvYmplY3QsIHNlcmlhbGl6ZSB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgIG9wdHMuYm9keSA9IG9wdHMucGFyYW1zU2VyaWFsaXplclxuICAgICAgICAgICAgICAgICAgICA/IG9wdHMucGFyYW1zU2VyaWFsaXplcihvcHRzLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVwYXJlZEhlYWRlcnMuaGFzKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlZEhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgICAgICAgb3B0cy5ib2R5ID0gb3B0cy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMudmFsaWRhdGVTdGF0dXMgPSBvcHRzLnZhbGlkYXRlU3RhdHVzIHx8IHRoaXMudmFsaWRhdGVTdGF0dXM7XG4gICAgICAgIG9wdHMucmVzcG9uc2VUeXBlID0gb3B0cy5yZXNwb25zZVR5cGUgfHwgJ3Vua25vd24nO1xuICAgICAgICBpZiAoIXByZXBhcmVkSGVhZGVycy5oYXMoJ2FjY2VwdCcpICYmIG9wdHMucmVzcG9uc2VUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHByZXBhcmVkSGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHkgPSBvcHRzLnByb3h5IHx8XG4gICAgICAgICAgICBwcm9jZXNzPy5lbnY/LkhUVFBTX1BST1hZIHx8XG4gICAgICAgICAgICBwcm9jZXNzPy5lbnY/Lmh0dHBzX3Byb3h5IHx8XG4gICAgICAgICAgICBwcm9jZXNzPy5lbnY/LkhUVFBfUFJPWFkgfHxcbiAgICAgICAgICAgIHByb2Nlc3M/LmVudj8uaHR0cF9wcm94eTtcbiAgICAgICAgaWYgKG9wdHMuYWdlbnQpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGRvIGFueSBvZiB0aGUgZm9sbG93aW5nIG9wdGlvbnMgLSB1c2UgdGhlIHVzZXItcHJvdmlkZWQgYWdlbnQuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJveHkgJiYgdGhpcy4jdXJsTWF5VXNlUHJveHkob3B0cy51cmwsIG9wdHMubm9Qcm94eSkpIHtcbiAgICAgICAgICAgIGNvbnN0IEh0dHBzUHJveHlBZ2VudCA9IGF3YWl0IF9hLiNnZXRQcm94eUFnZW50KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hZ2VudENhY2hlLmhhcyhwcm94eSkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudENhY2hlLmdldChwcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gbmV3IEh0dHBzUHJveHlBZ2VudChwcm94eSwge1xuICAgICAgICAgICAgICAgICAgICBjZXJ0OiBvcHRzLmNlcnQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogb3B0cy5rZXksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ2VudENhY2hlLnNldChwcm94eSwgb3B0cy5hZ2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5jZXJ0ICYmIG9wdHMua2V5KSB7XG4gICAgICAgICAgICAvLyBDb25maWd1cmUgY2xpZW50IGZvciBtVExTXG4gICAgICAgICAgICBpZiAodGhpcy5hZ2VudENhY2hlLmhhcyhvcHRzLmtleSkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudENhY2hlLmdldChvcHRzLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gbmV3IGh0dHBzXzEuQWdlbnQoe1xuICAgICAgICAgICAgICAgICAgICBjZXJ0OiBvcHRzLmNlcnQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogb3B0cy5rZXksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ2VudENhY2hlLnNldChvcHRzLmtleSwgb3B0cy5hZ2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmVycm9yUmVkYWN0b3IgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdHMuZXJyb3JSZWRhY3RvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9wdHMuZXJyb3JSZWRhY3RvciA9IGNvbW1vbl9qc18xLmRlZmF1bHRFcnJvclJlZGFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmJvZHkgJiYgISgnZHVwbGV4JyBpbiBvcHRzKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXF1aXJlZCBmb3IgTm9kZS5qcyBhbmQgdGhlIHR5cGUgaXNuJ3QgYXZhaWxhYmxlIHRvZGF5XG4gICAgICAgICAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ2MjIxXG4gICAgICAgICAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvaXNzdWVzLzE0ODNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb3B0cy5kdXBsZXggPSAnaGFsZic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYXBwZW5kVGltZW91dFRvU2lnbmFsKG9wdHMpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvcHRzLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBwcmVwYXJlZEhlYWRlcnMsXG4gICAgICAgICAgICB1cmw6IG9wdHMudXJsIGluc3RhbmNlb2YgVVJMID8gb3B0cy51cmwgOiBuZXcgVVJMKG9wdHMudXJsKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICNhcHBlbmRUaW1lb3V0VG9TaWduYWwob3B0cykge1xuICAgICAgICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0U2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dChvcHRzLnRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKG9wdHMuc2lnbmFsICYmICFvcHRzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5zaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW29wdHMuc2lnbmFsLCB0aW1lb3V0U2lnbmFsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLnNpZ25hbCA9IHRpbWVvdXRTaWduYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhyb3cgZm9yIGFueSBub24tMnh4IHN0YXR1cyBjb2RlXG4gICAgICogQHBhcmFtIHN0YXR1cyBzdGF0dXMgY29kZSBmcm9tIHRoZSBIVFRQIHJlc3BvbnNlXG4gICAgICovXG4gICAgdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSByZXNwb25zZSBieSBsb29raW5nIGF0IHRoZSBDb250ZW50LVR5cGUgaGVhZGVyLlxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlIHRoZSBIVFRQIHJlc3BvbnNlLlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlc3BvbnNlRGF0YUZyb21Db250ZW50VHlwZShyZXNwb25zZSkge1xuICAgICAgICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTWFpbnRhaW4gZXhpc3RpbmcgZnVuY3Rpb25hbGl0eSBieSBjYWxsaW5nIHRleHQoKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUeXBlLm1hdGNoKC9edGV4dFxcLy8pKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgdHlwZSBpcyBzb21ldGhpbmcgbm90IGVhc2lseSBoYW5kbGVkLCBqdXN0IHJldHVybiB0aGUgcmF3IGRhdGEgKGJsb2IpXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmMgZ2VuZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBwaWVjZXMgb2YgYSBtdWx0aXBhcnQvcmVsYXRlZCByZXF1ZXN0IGJvZHkuXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoZSBzcGVjOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjM4Ny50eHQuIEhvd2V2ZXIsIHJlY3Vyc2l2ZVxuICAgICAqIG11bHRpcGFydC9yZWxhdGVkIHJlcXVlc3RzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7R2F4aW9NdWx0aXBhcnRPcHRpb25zW119IG11bHRpcGFydE9wdGlvbnMgdGhlIHBpZWNlcyB0byB0dXJuIGludG8gYSBtdWx0aXBhcnQvcmVsYXRlZCBib2R5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeSB0aGUgYm91bmRhcnkgc3RyaW5nIHRvIGJlIHBsYWNlZCBiZXR3ZWVuIGVhY2ggcGFydC5cbiAgICAgKi9cbiAgICBhc3luYyAqZ2V0TXVsdGlwYXJ0UmVxdWVzdChtdWx0aXBhcnRPcHRpb25zLCBib3VuZGFyeSkge1xuICAgICAgICBjb25zdCBmaW5hbGUgPSBgLS0ke2JvdW5kYXJ5fS0tYDtcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50UGFydCBvZiBtdWx0aXBhcnRPcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0Q29udGVudFR5cGUgPSBjdXJyZW50UGFydC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgICAgICBjb25zdCBwcmVhbWJsZSA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1UeXBlOiAke3BhcnRDb250ZW50VHlwZX1cXHJcXG5cXHJcXG5gO1xuICAgICAgICAgICAgeWllbGQgcHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRQYXJ0LmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY3VycmVudFBhcnQuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjdXJyZW50UGFydC5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgJ1xcclxcbic7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZmluYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIGZvciB0aGUgbGF6aWx5LWxvYWRlZCBwcm94eSBhZ2VudC5cbiAgICAgKlxuICAgICAqIFNob3VsZCB1c2Uge0BsaW5rIEdheGlvc1sjZ2V0UHJveHlBZ2VudF19IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIC8vIHVzaW5nIGBpbXBvcnRgIHRvIGR5bmFtaWNhbGx5IGltcG9ydCB0aGUgdHlwZXMgaGVyZVxuICAgIHN0YXRpYyAjcHJveHlBZ2VudDtcbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIGZvciB0aGUgbGF6aWx5LWxvYWRlZCBmZXRjaCBsaWJyYXJ5LlxuICAgICAqXG4gICAgICogU2hvdWxkIHVzZSB7QGxpbmsgR2F4aW9zWyNnZXRGZXRjaF19IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIC8vXG4gICAgc3RhdGljICNmZXRjaDtcbiAgICAvKipcbiAgICAgKiBJbXBvcnRzLCBjYWNoZXMsIGFuZCByZXR1cm5zIGEgcHJveHkgYWdlbnQgLSBpZiBub3QgYWxyZWFkeSBpbXBvcnRlZFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm94eSBhZ2VudFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyAjZ2V0UHJveHlBZ2VudCgpIHtcbiAgICAgICAgdGhpcy4jcHJveHlBZ2VudCB8fD0gKGF3YWl0IGltcG9ydCgnaHR0cHMtcHJveHktYWdlbnQnKSkuSHR0cHNQcm94eUFnZW50O1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJveHlBZ2VudDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jICNnZXRGZXRjaCgpIHtcbiAgICAgICAgY29uc3QgaGFzV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3c7XG4gICAgICAgIHRoaXMuI2ZldGNoIHx8PSBoYXNXaW5kb3dcbiAgICAgICAgICAgID8gd2luZG93LmZldGNoXG4gICAgICAgICAgICA6IChhd2FpdCBpbXBvcnQoJ25vZGUtZmV0Y2gnKSkuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZldGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgaGVhZGVycy5cbiAgICAgKiBJZiB0aGUgYmFzZSBoZWFkZXJzIGRvIG5vdCBleGlzdCBhIG5ldyBgSGVhZGVyc2Agb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVXNpbmcgdGhpcyB1dGlsaXR5IGNhbiBiZSBoZWxwZnVsIHdoZW4gdGhlIGhlYWRlcnMgYXJlIG5vdCBrbm93biB0byBleGlzdDpcbiAgICAgKiAtIGlmIHRoZXkgZXhpc3QgYXMgYEhlYWRlcnNgLCB0aGF0IGluc3RhbmNlIHdpbGwgYmUgdXNlZFxuICAgICAqICAgLSBpdCBpbXByb3ZlcyBwZXJmb3JtYW5jZSBhbmQgYWxsb3dzIHVzZXJzIHRvIHVzZSB0aGVpciBleGlzdGluZyByZWZlcmVuY2VzIHRvIHRoZWlyIGBIZWFkZXJzYFxuICAgICAqIC0gaWYgdGhleSBleGlzdCBpbiBhbm90aGVyIGZvcm0gKGBIZWFkZXJzSW5pdGApLCB0aGV5IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBuZXcgYEhlYWRlcnNgIG9iamVjdFxuICAgICAqIC0gaWYgdGhlIGJhc2UgaGVhZGVycyBkbyBub3QgZXhpc3QgYSBuZXcgYEhlYWRlcnNgIG9iamVjdCB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBiYXNlIGhlYWRlcnMgdG8gYXBwZW5kL292ZXJ3cml0ZSB0b1xuICAgICAqIEBwYXJhbSBhcHBlbmQgaGVhZGVycyB0byBhcHBlbmQvb3ZlcndyaXRlIHdpdGhcbiAgICAgKiBAcmV0dXJucyB0aGUgYmFzZSBoZWFkZXJzIGluc3RhbmNlIHdpdGggbWVyZ2VkIGBIZWFkZXJzYFxuICAgICAqL1xuICAgIHN0YXRpYyBtZXJnZUhlYWRlcnMoYmFzZSwgLi4uYXBwZW5kKSB7XG4gICAgICAgIGJhc2UgPSBiYXNlIGluc3RhbmNlb2YgSGVhZGVycyA/IGJhc2UgOiBuZXcgSGVhZGVycyhiYXNlKTtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXJzIG9mIGFwcGVuZCkge1xuICAgICAgICAgICAgY29uc3QgYWRkID0gaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBoZWFkZXJzIDogbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgICAgICBhZGQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHNldC1jb29raWUgaXMgdGhlIG9ubHkgaGVhZGVyIHRoYXQgd291bGQgcmVwZWF0LlxuICAgICAgICAgICAgICAgIC8vIEEgYml0IG9mIGJhY2tncm91bmQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IZWFkZXJzL2dldFNldENvb2tpZVxuICAgICAgICAgICAgICAgIGtleSA9PT0gJ3NldC1jb29raWUnID8gYmFzZS5hcHBlbmQoa2V5LCB2YWx1ZSkgOiBiYXNlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbmV4cG9ydHMuR2F4aW9zID0gR2F4aW9zO1xuX2EgPSBHYXhpb3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXhpb3MuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJfYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiR2F4aW9zIiwiZXh0ZW5kXzEiLCJyZXF1aXJlIiwiaHR0cHNfMSIsImNvbW1vbl9qc18xIiwicmV0cnlfanNfMSIsInN0cmVhbV8xIiwiaW50ZXJjZXB0b3JfanNfMSIsInJhbmRvbVVVSUQiLCJnbG9iYWxUaGlzIiwiY3J5cHRvIiwiY29uc3RydWN0b3IiLCJkZWZhdWx0cyIsImFnZW50Q2FjaGUiLCJNYXAiLCJpbnRlcmNlcHRvcnMiLCJyZXF1ZXN0IiwiR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyIiwicmVzcG9uc2UiLCJmZXRjaCIsImFyZ3MiLCJpbnB1dCIsImluaXQiLCJ1cmwiLCJ1bmRlZmluZWQiLCJoZWFkZXJzIiwiSGVhZGVycyIsIlVSTCIsIm1lcmdlSGVhZGVycyIsIm9wdHMiLCJwcmVwYXJlZCIsInByZXBhcmVSZXF1ZXN0IiwiYXBwbHlSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiYXBwbHlSZXNwb25zZUludGVyY2VwdG9ycyIsIl9yZXF1ZXN0IiwiX2RlZmF1bHRBZGFwdGVyIiwiY29uZmlnIiwiZmV0Y2hJbXBsIiwiZmV0Y2hJbXBsZW1lbnRhdGlvbiIsImdldEZldGNoIiwicHJlcGFyZWRPcHRzIiwiZGF0YSIsInJlcyIsImdldFJlc3BvbnNlRGF0YSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJhc3NpZ24iLCJ0cmFuc2xhdGVkUmVzcG9uc2UiLCJhZGFwdGVyIiwiYmluZCIsInZhbGlkYXRlU3RhdHVzIiwic3RhdHVzIiwicmVzcG9uc2VUeXBlIiwiY2h1bmsiLCJwdXNoIiwiZXJyb3JJbmZvIiwiR2F4aW9zRXJyb3IiLCJleHRyYWN0QVBJRXJyb3JGcm9tUmVzcG9uc2UiLCJtZXNzYWdlIiwiZSIsImVyciIsIkVycm9yIiwic2hvdWxkUmV0cnkiLCJnZXRSZXRyeUNvbmZpZyIsInJldHJ5Q29uZmlnIiwiY3VycmVudFJldHJ5QXR0ZW1wdCIsImFwcGVuZFRpbWVvdXRUb1NpZ25hbCIsImVycm9yUmVkYWN0b3IiLCJtYXhDb250ZW50TGVuZ3RoIiwiaGFzIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJnZXQiLCJib2R5IiwianNvbiIsImFycmF5QnVmZmVyIiwiYmxvYiIsInRleHQiLCJnZXRSZXNwb25zZURhdGFGcm9tQ29udGVudFR5cGUiLCJ1cmxNYXlVc2VQcm94eSIsIm5vUHJveHkiLCJjYW5kaWRhdGUiLCJub1Byb3h5TGlzdCIsIm5vUHJveHlFbnZMaXN0IiwicHJvY2VzcyIsImVudiIsIk5PX1BST1hZIiwibm9fcHJveHkiLCJzcGxpdCIsInJ1bGUiLCJ0cmltIiwiUmVnRXhwIiwidGVzdCIsInRvU3RyaW5nIiwib3JpZ2luIiwic3RhcnRzV2l0aCIsImNsZWFuZWRSdWxlIiwicmVwbGFjZSIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJocmVmIiwib3B0aW9ucyIsInByb21pc2VDaGFpbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW50ZXJjZXB0b3IiLCJ2YWx1ZXMiLCJ0aGVuIiwicmVzb2x2ZWQiLCJyZWplY3RlZCIsInByZXBhcmVkSGVhZGVycyIsImRlZmF1bHQiLCJiYXNlVVJMIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsImFkZGl0aW9uYWxRdWVyeVBhcmFtcyIsInNsaWNlIiwicHJlZml4IiwiaW5jbHVkZXMiLCJrZXkiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJzaXplIiwibWF4UmVkaXJlY3RzIiwiZm9sbG93Iiwic2hvdWxkRGlyZWN0bHlQYXNzRGF0YSIsIkFycmF5QnVmZmVyIiwiQmxvYiIsIkZpbGUiLCJGb3JtRGF0YSIsIlJlYWRhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJTdHJpbmciLCJpc1ZpZXciLCJuYW1lIiwibXVsdGlwYXJ0IiwibGVuZ3RoIiwiYm91bmRhcnkiLCJzZXQiLCJmcm9tIiwiZ2V0TXVsdGlwYXJ0UmVxdWVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcm94eSIsIkhUVFBTX1BST1hZIiwiaHR0cHNfcHJveHkiLCJIVFRQX1BST1hZIiwiaHR0cF9wcm94eSIsImFnZW50IiwiSHR0cHNQcm94eUFnZW50IiwiZ2V0UHJveHlBZ2VudCIsImNlcnQiLCJBZ2VudCIsImRlZmF1bHRFcnJvclJlZGFjdG9yIiwiZHVwbGV4IiwidGltZW91dCIsInRpbWVvdXRTaWduYWwiLCJBYm9ydFNpZ25hbCIsInNpZ25hbCIsImFib3J0ZWQiLCJhbnkiLCJjb250ZW50VHlwZSIsInRvTG93ZXJDYXNlIiwicGFyc2UiLCJtYXRjaCIsIm11bHRpcGFydE9wdGlvbnMiLCJmaW5hbGUiLCJjdXJyZW50UGFydCIsInBhcnRDb250ZW50VHlwZSIsInByZWFtYmxlIiwiY29udGVudCIsInByb3h5QWdlbnQiLCJoYXNXaW5kb3ciLCJ3aW5kb3ciLCJiYXNlIiwiYWRkIiwiZm9yRWFjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/gaxios.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.instance = exports.Gaxios = exports.GaxiosError = void 0;\nexports.request = request;\nconst gaxios_js_1 = __webpack_require__(/*! ./gaxios.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/gaxios.js\");\nObject.defineProperty(exports, \"Gaxios\", ({\n    enumerable: true,\n    get: function() {\n        return gaxios_js_1.Gaxios;\n    }\n}));\nvar common_js_1 = __webpack_require__(/*! ./common.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/common.js\");\nObject.defineProperty(exports, \"GaxiosError\", ({\n    enumerable: true,\n    get: function() {\n        return common_js_1.GaxiosError;\n    }\n}));\n__exportStar(__webpack_require__(/*! ./interceptor.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js\"), exports);\n/**\n * The default instance used when the `request` method is directly\n * invoked.\n */ exports.instance = new gaxios_js_1.Gaxios();\n/**\n * Make an HTTP request using the given options.\n * @param opts Options for the request\n */ async function request(opts) {\n    return exports.instance.request(opts);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RMLGdCQUFnQixHQUFHQSxjQUFjLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDL0RBLGVBQWUsR0FBR1M7QUFDbEIsTUFBTUMsY0FBY0MsbUJBQU9BLENBQUMsd0VBQWE7QUFDekMzQiwwQ0FBeUM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2EsWUFBWUgsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9HLElBQUlLLGNBQWNELG1CQUFPQSxDQUFDLHdFQUFhO0FBQ3ZDM0IsK0NBQThDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9lLFlBQVlKLFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN6SFQsYUFBYVksbUJBQU9BLENBQUMsa0ZBQWtCLEdBQUdYO0FBQzFDOzs7Q0FHQyxHQUNEQSxnQkFBZ0IsR0FBRyxJQUFJVSxZQUFZSCxNQUFNO0FBQ3pDOzs7Q0FHQyxHQUNELGVBQWVFLFFBQVFJLElBQUk7SUFDdkIsT0FBT2IsUUFBUU0sUUFBUSxDQUFDRyxPQUFPLENBQUNJO0FBQ3BDLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluay1zYXZlci1hdXRvLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvaW5kZXguanM/YjY4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluc3RhbmNlID0gZXhwb3J0cy5HYXhpb3MgPSBleHBvcnRzLkdheGlvc0Vycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWVzdDtcbmNvbnN0IGdheGlvc19qc18xID0gcmVxdWlyZShcIi4vZ2F4aW9zLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2F4aW9zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnYXhpb3NfanNfMS5HYXhpb3M7IH0gfSk7XG52YXIgY29tbW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHYXhpb3NFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uX2pzXzEuR2F4aW9zRXJyb3I7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJjZXB0b3IuanNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBpbnN0YW5jZSB1c2VkIHdoZW4gdGhlIGByZXF1ZXN0YCBtZXRob2QgaXMgZGlyZWN0bHlcbiAqIGludm9rZWQuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2UgPSBuZXcgZ2F4aW9zX2pzXzEuR2F4aW9zKCk7XG4vKipcbiAqIE1ha2UgYW4gSFRUUCByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdHMgT3B0aW9ucyBmb3IgdGhlIHJlcXVlc3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdChvcHRzKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaW5zdGFuY2UucmVxdWVzdChvcHRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwiaW5zdGFuY2UiLCJHYXhpb3MiLCJHYXhpb3NFcnJvciIsInJlcXVlc3QiLCJnYXhpb3NfanNfMSIsInJlcXVpcmUiLCJjb21tb25fanNfMSIsIm9wdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/interceptor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2024 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GaxiosInterceptorManager = void 0;\n/**\n * Class to manage collections of GaxiosInterceptors for both requests and responses.\n */ class GaxiosInterceptorManager extends Set {\n}\nexports.GaxiosInterceptorManager = GaxiosInterceptorManager; //# sourceMappingURL=interceptor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvaW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHLEtBQUs7QUFDeEM7O0NBRUMsR0FDRCxNQUFNRSxpQ0FBaUNDO0FBQ3ZDO0FBQ0FILGdDQUFnQyxHQUFHRSwwQkFDbkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluay1zYXZlci1hdXRvLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvaW50ZXJjZXB0b3IuanM/NjY4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HYXhpb3NJbnRlcmNlcHRvck1hbmFnZXIgPSB2b2lkIDA7XG4vKipcbiAqIENsYXNzIHRvIG1hbmFnZSBjb2xsZWN0aW9ucyBvZiBHYXhpb3NJbnRlcmNlcHRvcnMgZm9yIGJvdGggcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyIGV4dGVuZHMgU2V0IHtcbn1cbmV4cG9ydHMuR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyID0gR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJjZXB0b3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyIiwiU2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/retry.js":
/*!****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/retry.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getRetryConfig = getRetryConfig;\nasync function getRetryConfig(err) {\n    let config = getConfig(err);\n    if (!err || !err.config || !config && !err.config.retry) {\n        return {\n            shouldRetry: false\n        };\n    }\n    config = config || {};\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    config.retry = config.retry === undefined || config.retry === null ? 3 : config.retry;\n    config.httpMethodsToRetry = config.httpMethodsToRetry || [\n        \"GET\",\n        \"HEAD\",\n        \"PUT\",\n        \"OPTIONS\",\n        \"DELETE\"\n    ];\n    config.noResponseRetries = config.noResponseRetries === undefined || config.noResponseRetries === null ? 2 : config.noResponseRetries;\n    config.retryDelayMultiplier = config.retryDelayMultiplier ? config.retryDelayMultiplier : 2;\n    config.timeOfFirstRequest = config.timeOfFirstRequest ? config.timeOfFirstRequest : Date.now();\n    config.totalTimeout = config.totalTimeout ? config.totalTimeout : Number.MAX_SAFE_INTEGER;\n    config.maxRetryDelay = config.maxRetryDelay ? config.maxRetryDelay : Number.MAX_SAFE_INTEGER;\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    const retryRanges = [\n        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n        // 1xx - Retry (Informational, request still processing)\n        // 2xx - Do not retry (Success)\n        // 3xx - Do not retry (Redirect)\n        // 4xx - Do not retry (Client errors)\n        // 408 - Retry (\"Request Timeout\")\n        // 429 - Retry (\"Too Many Requests\")\n        // 5xx - Retry (Server errors)\n        [\n            100,\n            199\n        ],\n        [\n            408,\n            408\n        ],\n        [\n            429,\n            429\n        ],\n        [\n            500,\n            599\n        ]\n    ];\n    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;\n    // Put the config back into the err\n    err.config.retryConfig = config;\n    // Determine if we should retry the request\n    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n    if (!await shouldRetryFn(err)) {\n        return {\n            shouldRetry: false,\n            config: err.config\n        };\n    }\n    const delay = getNextRetryDelay(config);\n    // We're going to retry!  Increment the counter.\n    err.config.retryConfig.currentRetryAttempt += 1;\n    // Create a promise that invokes the retry after the backOffDelay\n    const backoff = config.retryBackoff ? config.retryBackoff(err, delay) : new Promise((resolve)=>{\n        setTimeout(resolve, delay);\n    });\n    // Notify the user if they added an `onRetryAttempt` handler\n    if (config.onRetryAttempt) {\n        await config.onRetryAttempt(err);\n    }\n    // Return the promise in which recalls Gaxios to retry the request\n    await backoff;\n    return {\n        shouldRetry: true,\n        config: err.config\n    };\n}\n/**\n * Determine based on config if we should retry the request.\n * @param err The GaxiosError passed to the interceptor.\n */ function shouldRetryRequest(err) {\n    const config = getConfig(err);\n    if (err.config.signal?.aborted && err.code !== \"TimeoutError\" || err.code === \"AbortError\") {\n        return false;\n    }\n    // If there's no config, or retries are disabled, return.\n    if (!config || config.retry === 0) {\n        return false;\n    }\n    // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n    if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n        return false;\n    }\n    // Only retry with configured HttpMethods.\n    if (!config.httpMethodsToRetry || !config.httpMethodsToRetry.includes(err.config.method?.toUpperCase() || \"GET\")) {\n        return false;\n    }\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    if (err.response && err.response.status) {\n        let isInRange = false;\n        for (const [min, max] of config.statusCodesToRetry){\n            const status = err.response.status;\n            if (status >= min && status <= max) {\n                isInRange = true;\n                break;\n            }\n        }\n        if (!isInRange) {\n            return false;\n        }\n    }\n    // If we are out of retry attempts, return\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    if (config.currentRetryAttempt >= config.retry) {\n        return false;\n    }\n    return true;\n}\n/**\n * Acquire the raxConfig object from an GaxiosError if available.\n * @param err The Gaxios error with a config object.\n */ function getConfig(err) {\n    if (err && err.config && err.config.retryConfig) {\n        return err.config.retryConfig;\n    }\n    return;\n}\n/**\n * Gets the delay to wait before the next retry.\n *\n * @param {RetryConfig} config The current set of retry options\n * @returns {number} the amount of ms to wait before the next retry attempt.\n */ function getNextRetryDelay(config) {\n    // Calculate time to wait with exponential backoff.\n    // If this is the first retry, look for a configured retryDelay.\n    const retryDelay = config.currentRetryAttempt ? 0 : config.retryDelay ?? 100;\n    // Formula: retryDelay + ((retryDelayMultiplier^currentRetryAttempt - 1 / 2) * 1000)\n    const calculatedDelay = retryDelay + (Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) / 2 * 1000;\n    const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);\n    return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);\n} //# sourceMappingURL=retry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvcmV0cnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHRTtBQUN6QixlQUFlQSxlQUFlQyxHQUFHO0lBQzdCLElBQUlDLFNBQVNDLFVBQVVGO0lBQ3ZCLElBQUksQ0FBQ0EsT0FBTyxDQUFDQSxJQUFJQyxNQUFNLElBQUssQ0FBQ0EsVUFBVSxDQUFDRCxJQUFJQyxNQUFNLENBQUNFLEtBQUssRUFBRztRQUN2RCxPQUFPO1lBQUVDLGFBQWE7UUFBTTtJQUNoQztJQUNBSCxTQUFTQSxVQUFVLENBQUM7SUFDcEJBLE9BQU9JLG1CQUFtQixHQUFHSixPQUFPSSxtQkFBbUIsSUFBSTtJQUMzREosT0FBT0UsS0FBSyxHQUNSRixPQUFPRSxLQUFLLEtBQUtHLGFBQWFMLE9BQU9FLEtBQUssS0FBSyxPQUFPLElBQUlGLE9BQU9FLEtBQUs7SUFDMUVGLE9BQU9NLGtCQUFrQixHQUFHTixPQUFPTSxrQkFBa0IsSUFBSTtRQUNyRDtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRE4sT0FBT08saUJBQWlCLEdBQ3BCUCxPQUFPTyxpQkFBaUIsS0FBS0YsYUFBYUwsT0FBT08saUJBQWlCLEtBQUssT0FDakUsSUFDQVAsT0FBT08saUJBQWlCO0lBQ2xDUCxPQUFPUSxvQkFBb0IsR0FBR1IsT0FBT1Esb0JBQW9CLEdBQ25EUixPQUFPUSxvQkFBb0IsR0FDM0I7SUFDTlIsT0FBT1Msa0JBQWtCLEdBQUdULE9BQU9TLGtCQUFrQixHQUMvQ1QsT0FB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SSxDQUFDQSxXQUFXO1lBQ1osT0FBTztRQUNYO0lBQ0o7SUFDQSwwQ0FBMEM7SUFDMUNyQyxPQUFPSSxtQkFBbUIsR0FBR0osT0FBT0ksbUJBQW1CLElBQUk7SUFDM0QsSUFBSUosT0FBT0ksbUJBQW1CLElBQUlKLE9BQU9FLEtBQUssRUFBRTtRQUM1QyxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7O0NBR0MsR0FDRCxTQUFTRCxVQUFVRixHQUFHO0lBQ2xCLElBQUlBLE9BQU9BLElBQUlDLE1BQU0sSUFBSUQsSUFBSUMsTUFBTSxDQUFDa0IsV0FBVyxFQUFFO1FBQzdDLE9BQU9uQixJQUFJQyxNQUFNLENBQUNrQixXQUFXO0lBQ2pDO0lBQ0E7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU0ksa0JBQWtCdEIsTUFBTTtJQUM3QixtREFBbUQ7SUFDbkQsZ0VBQWdFO0lBQ2hFLE1BQU13QyxhQUFheEMsT0FBT0ksbUJBQW1CLEdBQ3ZDLElBQ0NKLE9BQU93QyxVQUFVLElBQUk7SUFDNUIsb0ZBQW9GO0lBQ3BGLE1BQU1DLGtCQUFrQkQsYUFDcEIsQ0FBRUUsS0FBS0MsR0FBRyxDQUFDM0MsT0FBT1Esb0JBQW9CLEVBQUVSLE9BQU9JLG1CQUFtQixJQUFJLEtBQ2xFLElBQ0E7SUFDUixNQUFNd0Msb0JBQW9CNUMsT0FBT1ksWUFBWSxHQUFJRixDQUFBQSxLQUFLQyxHQUFHLEtBQUtYLE9BQU9TLGtCQUFrQjtJQUN2RixPQUFPaUMsS0FBS0osR0FBRyxDQUFDRyxpQkFBaUJHLG1CQUFtQjVDLE9BQU9lLGFBQWE7QUFDNUUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5rLXNhdmVyLWF1dG8tc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9nYXhpb3MvYnVpbGQvY2pzL3NyYy9yZXRyeS5qcz8yOTA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFJldHJ5Q29uZmlnID0gZ2V0UmV0cnlDb25maWc7XG5hc3luYyBmdW5jdGlvbiBnZXRSZXRyeUNvbmZpZyhlcnIpIHtcbiAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKGVycik7XG4gICAgaWYgKCFlcnIgfHwgIWVyci5jb25maWcgfHwgKCFjb25maWcgJiYgIWVyci5jb25maWcucmV0cnkpKSB7XG4gICAgICAgIHJldHVybiB7IHNob3VsZFJldHJ5OiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgPSBjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCB8fCAwO1xuICAgIGNvbmZpZy5yZXRyeSA9XG4gICAgICAgIGNvbmZpZy5yZXRyeSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5yZXRyeSA9PT0gbnVsbCA/IDMgOiBjb25maWcucmV0cnk7XG4gICAgY29uZmlnLmh0dHBNZXRob2RzVG9SZXRyeSA9IGNvbmZpZy5odHRwTWV0aG9kc1RvUmV0cnkgfHwgW1xuICAgICAgICAnR0VUJyxcbiAgICAgICAgJ0hFQUQnLFxuICAgICAgICAnUFVUJyxcbiAgICAgICAgJ09QVElPTlMnLFxuICAgICAgICAnREVMRVRFJyxcbiAgICBdO1xuICAgIGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcyA9XG4gICAgICAgIGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcyA9PT0gbnVsbFxuICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICA6IGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcztcbiAgICBjb25maWcucmV0cnlEZWxheU11bHRpcGxpZXIgPSBjb25maWcucmV0cnlEZWxheU11bHRpcGxpZXJcbiAgICAgICAgPyBjb25maWcucmV0cnlEZWxheU11bHRpcGxpZXJcbiAgICAgICAgOiAyO1xuICAgIGNvbmZpZy50aW1lT2ZGaXJzdFJlcXVlc3QgPSBjb25maWcudGltZU9mRmlyc3RSZXF1ZXN0XG4gICAgICAgID8gY29uZmlnLnRpbWVPZkZpcnN0UmVxdWVzdFxuICAgICAgICA6IERhdGUubm93KCk7XG4gICAgY29uZmlnLnRvdGFsVGltZW91dCA9IGNvbmZpZy50b3RhbFRpbWVvdXRcbiAgICAgICAgPyBjb25maWcudG90YWxUaW1lb3V0XG4gICAgICAgIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgY29uZmlnLm1heFJldHJ5RGVsYXkgPSBjb25maWcubWF4UmV0cnlEZWxheVxuICAgICAgICA/IGNvbmZpZy5tYXhSZXRyeURlbGF5XG4gICAgICAgIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgLy8gSWYgdGhpcyB3YXNuJ3QgaW4gdGhlIGxpc3Qgb2Ygc3RhdHVzIGNvZGVzIHdoZXJlIHdlIHdhbnRcbiAgICAvLyB0byBhdXRvbWF0aWNhbGx5IHJldHJ5LCByZXR1cm4uXG4gICAgY29uc3QgcmV0cnlSYW5nZXMgPSBbXG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfSFRUUF9zdGF0dXNfY29kZXNcbiAgICAgICAgLy8gMXh4IC0gUmV0cnkgKEluZm9ybWF0aW9uYWwsIHJlcXVlc3Qgc3RpbGwgcHJvY2Vzc2luZylcbiAgICAgICAgLy8gMnh4IC0gRG8gbm90IHJldHJ5IChTdWNjZXNzKVxuICAgICAgICAvLyAzeHggLSBEbyBub3QgcmV0cnkgKFJlZGlyZWN0KVxuICAgICAgICAvLyA0eHggLSBEbyBub3QgcmV0cnkgKENsaWVudCBlcnJvcnMpXG4gICAgICAgIC8vIDQwOCAtIFJldHJ5IChcIlJlcXVlc3QgVGltZW91dFwiKVxuICAgICAgICAvLyA0MjkgLSBSZXRyeSAoXCJUb28gTWFueSBSZXF1ZXN0c1wiKVxuICAgICAgICAvLyA1eHggLSBSZXRyeSAoU2VydmVyIGVycm9ycylcbiAgICAgICAgWzEwMCwgMTk5XSxcbiAgICAgICAgWzQwOCwgNDA4XSxcbiAgICAgICAgWzQyOSwgNDI5XSxcbiAgICAgICAgWzUwMCwgNTk5XSxcbiAgICBdO1xuICAgIGNvbmZpZy5zdGF0dXNDb2Rlc1RvUmV0cnkgPSBjb25maWcuc3RhdHVzQ29kZXNUb1JldHJ5IHx8IHJldHJ5UmFuZ2VzO1xuICAgIC8vIFB1dCB0aGUgY29uZmlnIGJhY2sgaW50byB0aGUgZXJyXG4gICAgZXJyLmNvbmZpZy5yZXRyeUNvbmZpZyA9IGNvbmZpZztcbiAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHJldHJ5IHRoZSByZXF1ZXN0XG4gICAgY29uc3Qgc2hvdWxkUmV0cnlGbiA9IGNvbmZpZy5zaG91bGRSZXRyeSB8fCBzaG91bGRSZXRyeVJlcXVlc3Q7XG4gICAgaWYgKCEoYXdhaXQgc2hvdWxkUmV0cnlGbihlcnIpKSkge1xuICAgICAgICByZXR1cm4geyBzaG91bGRSZXRyeTogZmFsc2UsIGNvbmZpZzogZXJyLmNvbmZpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IGdldE5leHRSZXRyeURlbGF5KGNvbmZpZyk7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmV0cnkhICBJbmNyZW1lbnQgdGhlIGNvdW50ZXIuXG4gICAgZXJyLmNvbmZpZy5yZXRyeUNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0ICs9IDE7XG4gICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IGludm9rZXMgdGhlIHJldHJ5IGFmdGVyIHRoZSBiYWNrT2ZmRGVsYXlcbiAgICBjb25zdCBiYWNrb2ZmID0gY29uZmlnLnJldHJ5QmFja29mZlxuICAgICAgICA/IGNvbmZpZy5yZXRyeUJhY2tvZmYoZXJyLCBkZWxheSlcbiAgICAgICAgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpO1xuICAgICAgICB9KTtcbiAgICAvLyBOb3RpZnkgdGhlIHVzZXIgaWYgdGhleSBhZGRlZCBhbiBgb25SZXRyeUF0dGVtcHRgIGhhbmRsZXJcbiAgICBpZiAoY29uZmlnLm9uUmV0cnlBdHRlbXB0KSB7XG4gICAgICAgIGF3YWl0IGNvbmZpZy5vblJldHJ5QXR0ZW1wdChlcnIpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIHByb21pc2UgaW4gd2hpY2ggcmVjYWxscyBHYXhpb3MgdG8gcmV0cnkgdGhlIHJlcXVlc3RcbiAgICBhd2FpdCBiYWNrb2ZmO1xuICAgIHJldHVybiB7IHNob3VsZFJldHJ5OiB0cnVlLCBjb25maWc6IGVyci5jb25maWcgfTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIGJhc2VkIG9uIGNvbmZpZyBpZiB3ZSBzaG91bGQgcmV0cnkgdGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0gZXJyIFRoZSBHYXhpb3NFcnJvciBwYXNzZWQgdG8gdGhlIGludGVyY2VwdG9yLlxuICovXG5mdW5jdGlvbiBzaG91bGRSZXRyeVJlcXVlc3QoZXJyKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKGVycik7XG4gICAgaWYgKChlcnIuY29uZmlnLnNpZ25hbD8uYWJvcnRlZCAmJiBlcnIuY29kZSAhPT0gJ1RpbWVvdXRFcnJvcicpIHx8XG4gICAgICAgIGVyci5jb2RlID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGNvbmZpZywgb3IgcmV0cmllcyBhcmUgZGlzYWJsZWQsIHJldHVybi5cbiAgICBpZiAoIWNvbmZpZyB8fCBjb25maWcucmV0cnkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGlzIGVycm9yIGhhcyBubyByZXNwb25zZSAoRVRJTUVET1VULCBFTk9URk9VTkQsIGV0YylcbiAgICBpZiAoIWVyci5yZXNwb25zZSAmJlxuICAgICAgICAoY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgfHwgMCkgPj0gY29uZmlnLm5vUmVzcG9uc2VSZXRyaWVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT25seSByZXRyeSB3aXRoIGNvbmZpZ3VyZWQgSHR0cE1ldGhvZHMuXG4gICAgaWYgKCFjb25maWcuaHR0cE1ldGhvZHNUb1JldHJ5IHx8XG4gICAgICAgICFjb25maWcuaHR0cE1ldGhvZHNUb1JldHJ5LmluY2x1ZGVzKGVyci5jb25maWcubWV0aG9kPy50b1VwcGVyQ2FzZSgpIHx8ICdHRVQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgd2Fzbid0IGluIHRoZSBsaXN0IG9mIHN0YXR1cyBjb2RlcyB3aGVyZSB3ZSB3YW50XG4gICAgLy8gdG8gYXV0b21hdGljYWxseSByZXRyeSwgcmV0dXJuLlxuICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICBsZXQgaXNJblJhbmdlID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBjb25maWcuc3RhdHVzQ29kZXNUb1JldHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnIucmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA+PSBtaW4gJiYgc3RhdHVzIDw9IG1heCkge1xuICAgICAgICAgICAgICAgIGlzSW5SYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0luUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBhcmUgb3V0IG9mIHJldHJ5IGF0dGVtcHRzLCByZXR1cm5cbiAgICBjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCA9IGNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0IHx8IDA7XG4gICAgaWYgKGNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0ID49IGNvbmZpZy5yZXRyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBBY3F1aXJlIHRoZSByYXhDb25maWcgb2JqZWN0IGZyb20gYW4gR2F4aW9zRXJyb3IgaWYgYXZhaWxhYmxlLlxuICogQHBhcmFtIGVyciBUaGUgR2F4aW9zIGVycm9yIHdpdGggYSBjb25maWcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRDb25maWcoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29uZmlnICYmIGVyci5jb25maWcucmV0cnlDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGVyci5jb25maWcucmV0cnlDb25maWc7XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogR2V0cyB0aGUgZGVsYXkgdG8gd2FpdCBiZWZvcmUgdGhlIG5leHQgcmV0cnkuXG4gKlxuICogQHBhcmFtIHtSZXRyeUNvbmZpZ30gY29uZmlnIFRoZSBjdXJyZW50IHNldCBvZiByZXRyeSBvcHRpb25zXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgYW1vdW50IG9mIG1zIHRvIHdhaXQgYmVmb3JlIHRoZSBuZXh0IHJldHJ5IGF0dGVtcHQuXG4gKi9cbmZ1bmN0aW9uIGdldE5leHRSZXRyeURlbGF5KGNvbmZpZykge1xuICAgIC8vIENhbGN1bGF0ZSB0aW1lIHRvIHdhaXQgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHJldHJ5LCBsb29rIGZvciBhIGNvbmZpZ3VyZWQgcmV0cnlEZWxheS5cbiAgICBjb25zdCByZXRyeURlbGF5ID0gY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHRcbiAgICAgICAgPyAwXG4gICAgICAgIDogKGNvbmZpZy5yZXRyeURlbGF5ID8/IDEwMCk7XG4gICAgLy8gRm9ybXVsYTogcmV0cnlEZWxheSArICgocmV0cnlEZWxheU11bHRpcGxpZXJeY3VycmVudFJldHJ5QXR0ZW1wdCAtIDEgLyAyKSAqIDEwMDApXG4gICAgY29uc3QgY2FsY3VsYXRlZERlbGF5ID0gcmV0cnlEZWxheSArXG4gICAgICAgICgoTWF0aC5wb3coY29uZmlnLnJldHJ5RGVsYXlNdWx0aXBsaWVyLCBjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCkgLSAxKSAvXG4gICAgICAgICAgICAyKSAqXG4gICAgICAgICAgICAxMDAwO1xuICAgIGNvbnN0IG1heEFsbG93YWJsZURlbGF5ID0gY29uZmlnLnRvdGFsVGltZW91dCAtIChEYXRlLm5vdygpIC0gY29uZmlnLnRpbWVPZkZpcnN0UmVxdWVzdCk7XG4gICAgcmV0dXJuIE1hdGgubWluKGNhbGN1bGF0ZWREZWxheSwgbWF4QWxsb3dhYmxlRGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFJldHJ5Q29uZmlnIiwiZXJyIiwiY29uZmlnIiwiZ2V0Q29uZmlnIiwicmV0cnkiLCJzaG91bGRSZXRyeSIsImN1cnJlbnRSZXRyeUF0dGVtcHQiLCJ1bmRlZmluZWQiLCJodHRwTWV0aG9kc1RvUmV0cnkiLCJub1Jlc3BvbnNlUmV0cmllcyIsInJldHJ5RGVsYXlNdWx0aXBsaWVyIiwidGltZU9mRmlyc3RSZXF1ZXN0IiwiRGF0ZSIsIm5vdyIsInRvdGFsVGltZW91dCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtYXhSZXRyeURlbGF5IiwicmV0cnlSYW5nZXMiLCJzdGF0dXNDb2Rlc1RvUmV0cnkiLCJyZXRyeUNvbmZpZyIsInNob3VsZFJldHJ5Rm4iLCJzaG91bGRSZXRyeVJlcXVlc3QiLCJkZWxheSIsImdldE5leHRSZXRyeURlbGF5IiwiYmFja29mZiIsInJldHJ5QmFja29mZiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIm9uUmV0cnlBdHRlbXB0Iiwic2lnbmFsIiwiYWJvcnRlZCIsImNvZGUiLCJyZXNwb25zZSIsImluY2x1ZGVzIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJzdGF0dXMiLCJpc0luUmFuZ2UiLCJtaW4iLCJtYXgiLCJyZXRyeURlbGF5IiwiY2FsY3VsYXRlZERlbGF5IiwiTWF0aCIsInBvdyIsIm1heEFsbG93YWJsZURlbGF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/retry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/node_modules/agent-base/dist/helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/gaxios/node_modules/agent-base/dist/helpers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.req = exports.json = exports.toBuffer = void 0;\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https = __importStar(__webpack_require__(/*! https */ \"https\"));\nasync function toBuffer(stream) {\n    let length = 0;\n    const chunks = [];\n    for await (const chunk of stream){\n        length += chunk.length;\n        chunks.push(chunk);\n    }\n    return Buffer.concat(chunks, length);\n}\nexports.toBuffer = toBuffer;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function json(stream) {\n    const buf = await toBuffer(stream);\n    const str = buf.toString(\"utf8\");\n    try {\n        return JSON.parse(str);\n    } catch (_err) {\n        const err = _err;\n        err.message += ` (input: ${str})`;\n        throw err;\n    }\n}\nexports.json = json;\nfunction req(url, opts = {}) {\n    const href = typeof url === \"string\" ? url : url.href;\n    const req = (href.startsWith(\"https:\") ? https : http).request(url, opts);\n    const promise = new Promise((resolve, reject)=>{\n        req.once(\"response\", resolve).once(\"error\", reject).end();\n    });\n    req.then = promise.then.bind(promise);\n    return req;\n}\nexports.req = req; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL2Rpc3QvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFVQyxHQUFHO0lBQzNELElBQUlBLE9BQU9BLElBQUlWLFVBQVUsRUFBRSxPQUFPVTtJQUNsQyxJQUFJQyxTQUFTLENBQUM7SUFDZCxJQUFJRCxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUlmLEtBQUtlLElBQUssSUFBSWYsTUFBTSxhQUFhSixPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS2YsSUFBSUwsZ0JBQWdCcUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0FwQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RPLFdBQVcsR0FBR0EsWUFBWSxHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3JELE1BQU1JLE9BQU9WLGFBQWFXLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ3hDLE1BQU1DLFFBQVFaLGFBQWFXLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzFDLGVBQWVGLFNBQVNJLE1BQU07SUFDMUIsSUFBSUMsU0FBUztJQUNiLE1BQU1DLFNBQVMsRUFBRTtJQUNqQixXQUFXLE1BQU1DLFNBQVNILE9BQVE7UUFDOUJDLFVBQVVFLE1BQU1GLE1BQU07UUFDdEJDLE9BQU9FLElBQUksQ0FBQ0Q7SUFDaEI7SUFDQSxPQUFPRSxPQUFPQyxNQUFNLENBQUNKLFFBQVFEO0FBQ2pDO0FBQ0FSLGdCQUFnQixHQUFHRztBQUNuQiw4REFBOEQ7QUFDOUQsZUFBZUQsS0FBS0ssTUFBTTtJQUN0QixNQUFNTyxNQUFNLE1BQU1YLFNBQVNJO0lBQzNCLE1BQU1RLE1BQU1ELElBQUlFLFFBQVEsQ0FBQztJQUN6QixJQUFJO1FBQ0EsT0FBT0MsS0FBS0MsS0FBSyxDQUFDSDtJQUN0QixFQUNBLE9BQU9JLE1BQU07UUFDVCxNQUFNQyxNQUFNRDtRQUNaQyxJQUFJQyxPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUVOLElBQUksQ0FBQyxDQUFDO1FBQ2pDLE1BQU1LO0lBQ1Y7QUFDSjtBQUNBcEIsWUFBWSxHQUFHRTtBQUNmLFNBQVNELElBQUlxQixHQUFHLEVBQUVDLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZCLE1BQU1DLE9BQU8sT0FBT0YsUUFBUSxXQUFXQSxNQUFNQSxJQUFJRSxJQUFJO0lBQ3JELE1BQU12QixNQUFNLENBQUN1QixLQUFLQyxVQUFVLENBQUMsWUFBWW5CLFFBQVFGLElBQUcsRUFBR3NCLE9BQU8sQ0FBQ0osS0FBS0M7SUFDcEUsTUFBTUksVUFBVSxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQ2xDN0IsSUFDSzhCLElBQUksQ0FBQyxZQUFZRixTQUNqQkUsSUFBSSxDQUFDLFNBQVNELFFBQ2RFLEdBQUc7SUFDWjtJQUNBL0IsSUFBSWdDLElBQUksR0FBR04sUUFBUU0sSUFBSSxDQUFDQyxJQUFJLENBQUNQO0lBQzdCLE9BQU8xQjtBQUNYO0FBQ0FELFdBQVcsR0FBR0MsS0FDZCxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5rLXNhdmVyLWF1dG8tc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9nYXhpb3Mvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9oZWxwZXJzLmpzPzhiZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxID0gZXhwb3J0cy5qc29uID0gZXhwb3J0cy50b0J1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBzXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIHRvQnVmZmVyKHN0cmVhbSkge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgIGxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpO1xufVxuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmFzeW5jIGZ1bmN0aW9uIGpzb24oc3RyZWFtKSB7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgdG9CdWZmZXIoc3RyZWFtKTtcbiAgICBjb25zdCBzdHIgPSBidWYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICBjb25zdCBlcnIgPSBfZXJyO1xuICAgICAgICBlcnIubWVzc2FnZSArPSBgIChpbnB1dDogJHtzdHJ9KWA7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5leHBvcnRzLmpzb24gPSBqc29uO1xuZnVuY3Rpb24gcmVxKHVybCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgaHJlZiA9IHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnID8gdXJsIDogdXJsLmhyZWY7XG4gICAgY29uc3QgcmVxID0gKGhyZWYuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QodXJsLCBvcHRzKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXFcbiAgICAgICAgICAgIC5vbmNlKCdyZXNwb25zZScsIHJlc29sdmUpXG4gICAgICAgICAgICAub25jZSgnZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAuZW5kKCk7XG4gICAgfSk7XG4gICAgcmVxLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICByZXR1cm4gcmVxO1xufVxuZXhwb3J0cy5yZXEgPSByZXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwicmVxIiwianNvbiIsInRvQnVmZmVyIiwiaHR0cCIsInJlcXVpcmUiLCJodHRwcyIsInN0cmVhbSIsImxlbmd0aCIsImNodW5rcyIsImNodW5rIiwicHVzaCIsIkJ1ZmZlciIsImNvbmNhdCIsImJ1ZiIsInN0ciIsInRvU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiX2VyciIsImVyciIsIm1lc3NhZ2UiLCJ1cmwiLCJvcHRzIiwiaHJlZiIsInN0YXJ0c1dpdGgiLCJyZXF1ZXN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25jZSIsImVuZCIsInRoZW4iLCJiaW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/node_modules/agent-base/dist/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/node_modules/agent-base/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/gaxios/node_modules/agent-base/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Agent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst http = __importStar(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\n__exportStar(__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/gaxios/node_modules/agent-base/dist/helpers.js\"), exports);\nconst INTERNAL = Symbol(\"AgentBaseInternalState\");\nclass Agent extends http.Agent {\n    constructor(opts){\n        super(opts);\n        this[INTERNAL] = {};\n    }\n    /**\n     * Determine whether this is an `http` or `https` request.\n     */ isSecureEndpoint(options) {\n        if (options) {\n            // First check the `secureEndpoint` property explicitly, since this\n            // means that a parent `Agent` is \"passing through\" to this instance.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof options.secureEndpoint === \"boolean\") {\n                return options.secureEndpoint;\n            }\n            // If no explicit `secure` endpoint, check if `protocol` property is\n            // set. This will usually be the case since using a full string URL\n            // or `URL` instance should be the most common usage.\n            if (typeof options.protocol === \"string\") {\n                return options.protocol === \"https:\";\n            }\n        }\n        // Finally, if no `protocol` property was set, then fall back to\n        // checking the stack trace of the current call stack, and try to\n        // detect the \"https\" module.\n        const { stack } = new Error();\n        if (typeof stack !== \"string\") return false;\n        return stack.split(\"\\n\").some((l)=>l.indexOf(\"(https.js:\") !== -1 || l.indexOf(\"node:https:\") !== -1);\n    }\n    // In order to support async signatures in `connect()` and Node's native\n    // connection pooling in `http.Agent`, the array of sockets for each origin\n    // has to be updated synchronously. This is so the length of the array is\n    // accurate when `addRequest()` is next called. We achieve this by creating a\n    // fake socket and adding it to `sockets[origin]` and incrementing\n    // `totalSocketCount`.\n    incrementSockets(name) {\n        // If `maxSockets` and `maxTotalSockets` are both Infinity then there is no\n        // need to create a fake socket because Node.js native connection pooling\n        // will never be invoked.\n        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {\n            return null;\n        }\n        // All instances of `sockets` are expected TypeScript errors. The\n        // alternative is to add it as a private property of this class but that\n        // will break TypeScript subclassing.\n        if (!this.sockets[name]) {\n            // @ts-expect-error `sockets` is readonly in `@types/node`\n            this.sockets[name] = [];\n        }\n        const fakeSocket = new net.Socket({\n            writable: false\n        });\n        this.sockets[name].push(fakeSocket);\n        // @ts-expect-error `totalSocketCount` isn't defined in `@types/node`\n        this.totalSocketCount++;\n        return fakeSocket;\n    }\n    decrementSockets(name, socket) {\n        if (!this.sockets[name] || socket === null) {\n            return;\n        }\n        const sockets = this.sockets[name];\n        const index = sockets.indexOf(socket);\n        if (index !== -1) {\n            sockets.splice(index, 1);\n            // @ts-expect-error  `totalSocketCount` isn't defined in `@types/node`\n            this.totalSocketCount--;\n            if (sockets.length === 0) {\n                // @ts-expect-error `sockets` is readonly in `@types/node`\n                delete this.sockets[name];\n            }\n        }\n    }\n    // In order to properly update the socket pool, we need to call `getName()` on\n    // the core `https.Agent` if it is a secureEndpoint.\n    getName(options) {\n        const secureEndpoint = this.isSecureEndpoint(options);\n        if (secureEndpoint) {\n            // @ts-expect-error `getName()` isn't defined in `@types/node`\n            return https_1.Agent.prototype.getName.call(this, options);\n        }\n        // @ts-expect-error `getName()` isn't defined in `@types/node`\n        return super.getName(options);\n    }\n    createSocket(req, options, cb) {\n        const connectOpts = {\n            ...options,\n            secureEndpoint: this.isSecureEndpoint(options)\n        };\n        const name = this.getName(connectOpts);\n        const fakeSocket = this.incrementSockets(name);\n        Promise.resolve().then(()=>this.connect(req, connectOpts)).then((socket)=>{\n            this.decrementSockets(name, fakeSocket);\n            if (socket instanceof http.Agent) {\n                try {\n                    // @ts-expect-error `addRequest()` isn't defined in `@types/node`\n                    return socket.addRequest(req, connectOpts);\n                } catch (err) {\n                    return cb(err);\n                }\n            }\n            this[INTERNAL].currentSocket = socket;\n            // @ts-expect-error `createSocket()` isn't defined in `@types/node`\n            super.createSocket(req, options, cb);\n        }, (err)=>{\n            this.decrementSockets(name, fakeSocket);\n            cb(err);\n        });\n    }\n    createConnection() {\n        const socket = this[INTERNAL].currentSocket;\n        this[INTERNAL].currentSocket = undefined;\n        if (!socket) {\n            throw new Error(\"No socket was returned in the `connect()` function\");\n        }\n        return socket;\n    }\n    get defaultPort() {\n        return this[INTERNAL].defaultPort ?? (this.protocol === \"https:\" ? 443 : 80);\n    }\n    set defaultPort(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].defaultPort = v;\n        }\n    }\n    get protocol() {\n        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? \"https:\" : \"http:\");\n    }\n    set protocol(v) {\n        if (this[INTERNAL]) {\n            this[INTERNAL].protocol = v;\n        }\n    }\n}\nexports.Agent = Agent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtB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SSxDQUFDSCxnQkFBZ0IsS0FBSyxXQUFXLE9BQU07SUFDcEQ7SUFDQSxJQUFJRyxTQUFTdkIsQ0FBQyxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUNnQixTQUFTLEVBQUU7WUFDaEIsSUFBSSxDQUFDQSxTQUFTLENBQUNPLFFBQVEsR0FBR3ZCO1FBQzlCO0lBQ0o7QUFDSjtBQUNBUyxhQUFhLEdBQUdFLE9BQ2hCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmstc2F2ZXItYXV0by1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL2dheGlvcy9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L2luZGV4LmpzP2YyNjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFnZW50ID0gdm9pZCAwO1xuY29uc3QgbmV0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgaHR0cCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cFwiKSk7XG5jb25zdCBodHRwc18xID0gcmVxdWlyZShcImh0dHBzXCIpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlcnNcIiksIGV4cG9ydHMpO1xuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woJ0FnZW50QmFzZUludGVybmFsU3RhdGUnKTtcbmNsYXNzIEFnZW50IGV4dGVuZHMgaHR0cC5BZ2VudCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpc1tJTlRFUk5BTF0gPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhbiBgaHR0cGAgb3IgYGh0dHBzYCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGlzU2VjdXJlRW5kcG9pbnQob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgdGhlIGBzZWN1cmVFbmRwb2ludGAgcHJvcGVydHkgZXhwbGljaXRseSwgc2luY2UgdGhpc1xuICAgICAgICAgICAgLy8gbWVhbnMgdGhhdCBhIHBhcmVudCBgQWdlbnRgIGlzIFwicGFzc2luZyB0aHJvdWdoXCIgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2VjdXJlRW5kcG9pbnQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNlY3VyZUVuZHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgYHNlY3VyZWAgZW5kcG9pbnQsIGNoZWNrIGlmIGBwcm90b2NvbGAgcHJvcGVydHkgaXNcbiAgICAgICAgICAgIC8vIHNldC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgdGhlIGNhc2Ugc2luY2UgdXNpbmcgYSBmdWxsIHN0cmluZyBVUkxcbiAgICAgICAgICAgIC8vIG9yIGBVUkxgIGluc3RhbmNlIHNob3VsZCBiZSB0aGUgbW9zdCBjb21tb24gdXNhZ2UuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsbHksIGlmIG5vIGBwcm90b2NvbGAgcHJvcGVydHkgd2FzIHNldCwgdGhlbiBmYWxsIGJhY2sgdG9cbiAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHN0YWNrIHRyYWNlIG9mIHRoZSBjdXJyZW50IGNhbGwgc3RhY2ssIGFuZCB0cnkgdG9cbiAgICAgICAgLy8gZGV0ZWN0IHRoZSBcImh0dHBzXCIgbW9kdWxlLlxuICAgICAgICBjb25zdCB7IHN0YWNrIH0gPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdGFja1xuICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgLnNvbWUoKGwpID0+IGwuaW5kZXhPZignKGh0dHBzLmpzOicpICE9PSAtMSB8fFxuICAgICAgICAgICAgbC5pbmRleE9mKCdub2RlOmh0dHBzOicpICE9PSAtMSk7XG4gICAgfVxuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgYXN5bmMgc2lnbmF0dXJlcyBpbiBgY29ubmVjdCgpYCBhbmQgTm9kZSdzIG5hdGl2ZVxuICAgIC8vIGNvbm5lY3Rpb24gcG9vbGluZyBpbiBgaHR0cC5BZ2VudGAsIHRoZSBhcnJheSBvZiBzb2NrZXRzIGZvciBlYWNoIG9yaWdpblxuICAgIC8vIGhhcyB0byBiZSB1cGRhdGVkIHN5bmNocm9ub3VzbHkuIFRoaXMgaXMgc28gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXNcbiAgICAvLyBhY2N1cmF0ZSB3aGVuIGBhZGRSZXF1ZXN0KClgIGlzIG5leHQgY2FsbGVkLiBXZSBhY2hpZXZlIHRoaXMgYnkgY3JlYXRpbmcgYVxuICAgIC8vIGZha2Ugc29ja2V0IGFuZCBhZGRpbmcgaXQgdG8gYHNvY2tldHNbb3JpZ2luXWAgYW5kIGluY3JlbWVudGluZ1xuICAgIC8vIGB0b3RhbFNvY2tldENvdW50YC5cbiAgICBpbmNyZW1lbnRTb2NrZXRzKG5hbWUpIHtcbiAgICAgICAgLy8gSWYgYG1heFNvY2tldHNgIGFuZCBgbWF4VG90YWxTb2NrZXRzYCBhcmUgYm90aCBJbmZpbml0eSB0aGVuIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIG5lZWQgdG8gY3JlYXRlIGEgZmFrZSBzb2NrZXQgYmVjYXVzZSBOb2RlLmpzIG5hdGl2ZSBjb25uZWN0aW9uIHBvb2xpbmdcbiAgICAgICAgLy8gd2lsbCBuZXZlciBiZSBpbnZva2VkLlxuICAgICAgICBpZiAodGhpcy5tYXhTb2NrZXRzID09PSBJbmZpbml0eSAmJiB0aGlzLm1heFRvdGFsU29ja2V0cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbCBpbnN0YW5jZXMgb2YgYHNvY2tldHNgIGFyZSBleHBlY3RlZCBUeXBlU2NyaXB0IGVycm9ycy4gVGhlXG4gICAgICAgIC8vIGFsdGVybmF0aXZlIGlzIHRvIGFkZCBpdCBhcyBhIHByaXZhdGUgcHJvcGVydHkgb2YgdGhpcyBjbGFzcyBidXQgdGhhdFxuICAgICAgICAvLyB3aWxsIGJyZWFrIFR5cGVTY3JpcHQgc3ViY2xhc3NpbmcuXG4gICAgICAgIGlmICghdGhpcy5zb2NrZXRzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBzb2NrZXRzYCBpcyByZWFkb25seSBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICB0aGlzLnNvY2tldHNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWtlU29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0c1tuYW1lXS5wdXNoKGZha2VTb2NrZXQpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGB0b3RhbFNvY2tldENvdW50YCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgdGhpcy50b3RhbFNvY2tldENvdW50Kys7XG4gICAgICAgIHJldHVybiBmYWtlU29ja2V0O1xuICAgIH1cbiAgICBkZWNyZW1lbnRTb2NrZXRzKG5hbWUsIHNvY2tldCkge1xuICAgICAgICBpZiAoIXRoaXMuc29ja2V0c1tuYW1lXSB8fCBzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRzID0gdGhpcy5zb2NrZXRzW25hbWVdO1xuICAgICAgICBjb25zdCBpbmRleCA9IHNvY2tldHMuaW5kZXhPZihzb2NrZXQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzb2NrZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICBgdG90YWxTb2NrZXRDb3VudGAgaXNuJ3QgZGVmaW5lZCBpbiBgQHR5cGVzL25vZGVgXG4gICAgICAgICAgICB0aGlzLnRvdGFsU29ja2V0Q291bnQtLTtcbiAgICAgICAgICAgIGlmIChzb2NrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYHNvY2tldHNgIGlzIHJlYWRvbmx5IGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zb2NrZXRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEluIG9yZGVyIHRvIHByb3Blcmx5IHVwZGF0ZSB0aGUgc29ja2V0IHBvb2wsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0TmFtZSgpYCBvblxuICAgIC8vIHRoZSBjb3JlIGBodHRwcy5BZ2VudGAgaWYgaXQgaXMgYSBzZWN1cmVFbmRwb2ludC5cbiAgICBnZXROYW1lKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VjdXJlRW5kcG9pbnQgPSB0aGlzLmlzU2VjdXJlRW5kcG9pbnQob3B0aW9ucyk7XG4gICAgICAgIGlmIChzZWN1cmVFbmRwb2ludCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgZ2V0TmFtZSgpYCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgICAgIHJldHVybiBodHRwc18xLkFnZW50LnByb3RvdHlwZS5nZXROYW1lLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgZ2V0TmFtZSgpYCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldE5hbWUob3B0aW9ucyk7XG4gICAgfVxuICAgIGNyZWF0ZVNvY2tldChyZXEsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RPcHRzID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNlY3VyZUVuZHBvaW50OiB0aGlzLmlzU2VjdXJlRW5kcG9pbnQob3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldE5hbWUoY29ubmVjdE9wdHMpO1xuICAgICAgICBjb25zdCBmYWtlU29ja2V0ID0gdGhpcy5pbmNyZW1lbnRTb2NrZXRzKG5hbWUpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5jb25uZWN0KHJlcSwgY29ubmVjdE9wdHMpKVxuICAgICAgICAgICAgLnRoZW4oKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWNyZW1lbnRTb2NrZXRzKG5hbWUsIGZha2VTb2NrZXQpO1xuICAgICAgICAgICAgaWYgKHNvY2tldCBpbnN0YW5jZW9mIGh0dHAuQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBhZGRSZXF1ZXN0KClgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0LmFkZFJlcXVlc3QocmVxLCBjb25uZWN0T3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tJTlRFUk5BTF0uY3VycmVudFNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGNyZWF0ZVNvY2tldCgpYCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWBcbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZVNvY2tldChyZXEsIG9wdGlvbnMsIGNiKTtcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWNyZW1lbnRTb2NrZXRzKG5hbWUsIGZha2VTb2NrZXQpO1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXNbSU5URVJOQUxdLmN1cnJlbnRTb2NrZXQ7XG4gICAgICAgIHRoaXNbSU5URVJOQUxdLmN1cnJlbnRTb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc29ja2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNvY2tldCB3YXMgcmV0dXJuZWQgaW4gdGhlIGBjb25uZWN0KClgIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRQb3J0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXNbSU5URVJOQUxdLmRlZmF1bHRQb3J0ID8/XG4gICAgICAgICAgICAodGhpcy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MCkpO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdFBvcnQodikge1xuICAgICAgICBpZiAodGhpc1tJTlRFUk5BTF0pIHtcbiAgICAgICAgICAgIHRoaXNbSU5URVJOQUxdLmRlZmF1bHRQb3J0ID0gdjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiAodGhpc1tJTlRFUk5BTF0ucHJvdG9jb2wgPz9cbiAgICAgICAgICAgICh0aGlzLmlzU2VjdXJlRW5kcG9pbnQoKSA/ICdodHRwczonIDogJ2h0dHA6JykpO1xuICAgIH1cbiAgICBzZXQgcHJvdG9jb2wodikge1xuICAgICAgICBpZiAodGhpc1tJTlRFUk5BTF0pIHtcbiAgICAgICAgICAgIHRoaXNbSU5URVJOQUxdLnByb3RvY29sID0gdjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWdlbnQgPSBBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsIkFnZW50IiwibmV0IiwicmVxdWlyZSIsImh0dHAiLCJodHRwc18xIiwiSU5URVJOQUwiLCJTeW1ib2wiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJpc1NlY3VyZUVuZHBvaW50Iiwib3B0aW9ucyIsInNlY3VyZUVuZHBvaW50IiwicHJvdG9jb2wiLCJzdGFjayIsIkVycm9yIiwic3BsaXQiLCJzb21lIiwibCIsImluZGV4T2YiLCJpbmNyZW1lbnRTb2NrZXRzIiwibmFtZSIsIm1heFNvY2tldHMiLCJJbmZpbml0eSIsIm1heFRvdGFsU29ja2V0cyIsInNvY2tldHMiLCJmYWtlU29ja2V0IiwiU29ja2V0IiwicHVzaCIsInRvdGFsU29ja2V0Q291bnQiLCJkZWNyZW1lbnRTb2NrZXRzIiwic29ja2V0IiwiaW5kZXgiLCJzcGxpY2UiLCJsZW5ndGgiLCJnZXROYW1lIiwiY3JlYXRlU29ja2V0IiwicmVxIiwiY2IiLCJjb25uZWN0T3B0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNvbm5lY3QiLCJhZGRSZXF1ZXN0IiwiZXJyIiwiY3VycmVudFNvY2tldCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJkZWZhdWx0UG9ydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/node_modules/agent-base/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/node_modules/https-proxy-agent/dist/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/gaxios/node_modules/https-proxy-agent/dist/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.HttpsProxyAgent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/gaxios/node_modules/agent-base/dist/index.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst parse_proxy_response_1 = __webpack_require__(/*! ./parse-proxy-response */ \"(rsc)/./node_modules/gaxios/node_modules/https-proxy-agent/dist/parse-proxy-response.js\");\nconst debug = (0, debug_1.default)(\"https-proxy-agent\");\nconst setServernameFromNonIpHost = (options)=>{\n    if (options.servername === undefined && options.host && !net.isIP(options.host)) {\n        return {\n            ...options,\n            servername: options.host\n        };\n    }\n    return options;\n};\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */ class HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(proxy, opts){\n        super(opts);\n        this.options = {\n            path: undefined\n        };\n        this.proxy = typeof proxy === \"string\" ? new url_1.URL(proxy) : proxy;\n        this.proxyHeaders = opts?.headers ?? {};\n        debug(\"Creating new HttpsProxyAgent instance: %o\", this.proxy.href);\n        // Trim off the brackets from IPv6 addresses\n        const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, \"\");\n        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === \"https:\" ? 443 : 80;\n        this.connectOpts = {\n            // Attempt to negotiate http/1.1 for proxy servers that support http/2\n            ALPNProtocols: [\n                \"http/1.1\"\n            ],\n            ...opts ? omit(opts, \"headers\") : null,\n            host,\n            port\n        };\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     */ async connect(req, opts) {\n        const { proxy } = this;\n        if (!opts.host) {\n            throw new TypeError('No \"host\" provided');\n        }\n        // Create a socket connection to the proxy server.\n        let socket;\n        if (proxy.protocol === \"https:\") {\n            debug(\"Creating `tls.Socket`: %o\", this.connectOpts);\n            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));\n        } else {\n            debug(\"Creating `net.Socket`: %o\", this.connectOpts);\n            socket = net.connect(this.connectOpts);\n        }\n        const headers = typeof this.proxyHeaders === \"function\" ? this.proxyHeaders() : {\n            ...this.proxyHeaders\n        };\n        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n        // Inject the `Proxy-Authorization` header if necessary.\n        if (proxy.username || proxy.password) {\n            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n            headers[\"Proxy-Authorization\"] = `Basic ${Buffer.from(auth).toString(\"base64\")}`;\n        }\n        headers.Host = `${host}:${opts.port}`;\n        if (!headers[\"Proxy-Connection\"]) {\n            headers[\"Proxy-Connection\"] = this.keepAlive ? \"Keep-Alive\" : \"close\";\n        }\n        for (const name of Object.keys(headers)){\n            payload += `${name}: ${headers[name]}\\r\\n`;\n        }\n        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);\n        socket.write(`${payload}\\r\\n`);\n        const { connect, buffered } = await proxyResponsePromise;\n        req.emit(\"proxyConnect\", connect);\n        this.emit(\"proxyConnect\", connect, req);\n        if (connect.statusCode === 200) {\n            req.once(\"socket\", resume);\n            if (opts.secureEndpoint) {\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                debug(\"Upgrading socket connection to TLS\");\n                return tls.connect({\n                    ...omit(setServernameFromNonIpHost(opts), \"host\", \"path\", \"port\"),\n                    socket\n                });\n            }\n            return socket;\n        }\n        // Some other status code that's not 200... need to re-play the HTTP\n        // header \"data\" events onto the socket once the HTTP machinery is\n        // attached so that the node core `http` can parse and handle the\n        // error status code.\n        // Close the original socket, and a new \"fake\" socket is returned\n        // instead, so that the proxy doesn't get the HTTP request\n        // written to it (which may contain `Authorization` headers or other\n        // sensitive data).\n        //\n        // See: https://hackerone.com/reports/541502\n        socket.destroy();\n        const fakeSocket = new net.Socket({\n            writable: false\n        });\n        fakeSocket.readable = true;\n        // Need to wait for the \"socket\" event to re-play the \"data\" events.\n        req.once(\"socket\", (s)=>{\n            debug(\"Replaying proxy buffer for failed request\");\n            (0, assert_1.default)(s.listenerCount(\"data\") > 0);\n            // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n            // this point the HTTP module machinery has been hooked up for\n            // the user.\n            s.push(buffered);\n            s.push(null);\n        });\n        return fakeSocket;\n    }\n}\nHttpsProxyAgent.protocols = [\n    \"http\",\n    \"https\"\n];\nexports.HttpsProxyAgent = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMs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TTtRQUNwRDRFLFdBQVdFLFFBQVEsR0FBRztRQUN0QixvRUFBb0U7UUFDcEU1QixJQUFJc0IsSUFBSSxDQUFDLFVBQVUsQ0FBQ087WUFDaEJ0RCxNQUFNO1lBQ0wsSUFBR0wsU0FBU00sT0FBTyxFQUFFcUQsRUFBRUMsYUFBYSxDQUFDLFVBQVU7WUFDaEQsZ0VBQWdFO1lBQ2hFLDhEQUE4RDtZQUM5RCxZQUFZO1lBQ1pELEVBQUVFLElBQUksQ0FBQ1o7WUFDUFUsRUFBRUUsSUFBSSxDQUFDO1FBQ1g7UUFDQSxPQUFPTDtJQUNYO0FBQ0o7QUFDQTVELGdCQUFnQmtFLFNBQVMsR0FBRztJQUFDO0lBQVE7Q0FBUTtBQUM3Q25FLHVCQUF1QixHQUFHQztBQUMxQixTQUFTeUQsT0FBT3JCLE1BQU07SUFDbEJBLE9BQU9xQixNQUFNO0FBQ2pCO0FBQ0EsU0FBU3pCLEtBQUttQyxHQUFHLEVBQUUsR0FBR2xCLElBQUk7SUFDdEIsTUFBTW1CLE1BQU0sQ0FBQztJQUNiLElBQUlDO0lBQ0osSUFBS0EsT0FBT0YsSUFBSztRQUNiLElBQUksQ0FBQ2xCLEtBQUtxQixRQUFRLENBQUNELE1BQU07WUFDckJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHRixHQUFHLENBQUNFLElBQUk7UUFDdkI7SUFDSjtJQUNBLE9BQU9EO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5rLXNhdmVyLWF1dG8tc3VtbWFyeS8uL25vZGVfbW9kdWxlcy9nYXhpb3Mvbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/ZTJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwc1Byb3h5QWdlbnQgPSB2b2lkIDA7XG5jb25zdCBuZXQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5ldFwiKSk7XG5jb25zdCB0bHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInRsc1wiKSk7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGFnZW50X2Jhc2VfMSA9IHJlcXVpcmUoXCJhZ2VudC1iYXNlXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgcGFyc2VfcHJveHlfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLXByb3h5LXJlc3BvbnNlXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnaHR0cHMtcHJveHktYWdlbnQnKTtcbmNvbnN0IHNldFNlcnZlcm5hbWVGcm9tTm9uSXBIb3N0ID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAob3B0aW9ucy5zZXJ2ZXJuYW1lID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgb3B0aW9ucy5ob3N0ICYmXG4gICAgICAgICFuZXQuaXNJUChvcHRpb25zLmhvc3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc2VydmVybmFtZTogb3B0aW9ucy5ob3N0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIFRoZSBgSHR0cHNQcm94eUFnZW50YCBpbXBsZW1lbnRzIGFuIEhUVFAgQWdlbnQgc3ViY2xhc3MgdGhhdCBjb25uZWN0cyB0b1xuICogdGhlIHNwZWNpZmllZCBcIkhUVFAocykgcHJveHkgc2VydmVyXCIgaW4gb3JkZXIgdG8gcHJveHkgSFRUUFMgcmVxdWVzdHMuXG4gKlxuICogT3V0Z29pbmcgSFRUUCByZXF1ZXN0cyBhcmUgZmlyc3QgdHVubmVsZWQgdGhyb3VnaCB0aGUgcHJveHkgc2VydmVyIHVzaW5nIHRoZVxuICogYENPTk5FQ1RgIEhUVFAgcmVxdWVzdCBtZXRob2QgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLFxuICogYW5kIHRoZW4gdGhlIHByb3h5IHNlcnZlciBjb25uZWN0cyB0byB0aGUgZGVzdGluYXRpb24gdGFyZ2V0IGFuZCBpc3N1ZXMgdGhlXG4gKiBIVFRQIHJlcXVlc3QgZnJvbSB0aGUgcHJveHkgc2VydmVyLlxuICpcbiAqIGBodHRwczpgIHJlcXVlc3RzIGhhdmUgdGhlaXIgc29ja2V0IGNvbm5lY3Rpb24gdXBncmFkZWQgdG8gVExTIG9uY2VcbiAqIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gKi9cbmNsYXNzIEh0dHBzUHJveHlBZ2VudCBleHRlbmRzIGFnZW50X2Jhc2VfMS5BZ2VudCB7XG4gICAgY29uc3RydWN0b3IocHJveHksIG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgcGF0aDogdW5kZWZpbmVkIH07XG4gICAgICAgIHRoaXMucHJveHkgPSB0eXBlb2YgcHJveHkgPT09ICdzdHJpbmcnID8gbmV3IHVybF8xLlVSTChwcm94eSkgOiBwcm94eTtcbiAgICAgICAgdGhpcy5wcm94eUhlYWRlcnMgPSBvcHRzPy5oZWFkZXJzID8/IHt9O1xuICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgbmV3IEh0dHBzUHJveHlBZ2VudCBpbnN0YW5jZTogJW8nLCB0aGlzLnByb3h5LmhyZWYpO1xuICAgICAgICAvLyBUcmltIG9mZiB0aGUgYnJhY2tldHMgZnJvbSBJUHY2IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBob3N0ID0gKHRoaXMucHJveHkuaG9zdG5hbWUgfHwgdGhpcy5wcm94eS5ob3N0KS5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5wcm94eS5wb3J0XG4gICAgICAgICAgICA/IHBhcnNlSW50KHRoaXMucHJveHkucG9ydCwgMTApXG4gICAgICAgICAgICA6IHRoaXMucHJveHkucHJvdG9jb2wgPT09ICdodHRwczonXG4gICAgICAgICAgICAgICAgPyA0NDNcbiAgICAgICAgICAgICAgICA6IDgwO1xuICAgICAgICB0aGlzLmNvbm5lY3RPcHRzID0ge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBuZWdvdGlhdGUgaHR0cC8xLjEgZm9yIHByb3h5IHNlcnZlcnMgdGhhdCBzdXBwb3J0IGh0dHAvMlxuICAgICAgICAgICAgQUxQTlByb3RvY29sczogWydodHRwLzEuMSddLFxuICAgICAgICAgICAgLi4uKG9wdHMgPyBvbWl0KG9wdHMsICdoZWFkZXJzJykgOiBudWxsKSxcbiAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbm9kZS1jb3JlIEhUVFAgY2xpZW50IGxpYnJhcnkgaXMgY3JlYXRpbmcgYVxuICAgICAqIG5ldyBIVFRQIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdChyZXEsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBwcm94eSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzLmhvc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIFwiaG9zdFwiIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgc29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlci5cbiAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgaWYgKHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8nLCB0aGlzLmNvbm5lY3RPcHRzKTtcbiAgICAgICAgICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHNldFNlcnZlcm5hbWVGcm9tTm9uSXBIb3N0KHRoaXMuY29ubmVjdE9wdHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvJywgdGhpcy5jb25uZWN0T3B0cyk7XG4gICAgICAgICAgICBzb2NrZXQgPSBuZXQuY29ubmVjdCh0aGlzLmNvbm5lY3RPcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gdHlwZW9mIHRoaXMucHJveHlIZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHRoaXMucHJveHlIZWFkZXJzKClcbiAgICAgICAgICAgIDogeyAuLi50aGlzLnByb3h5SGVhZGVycyB9O1xuICAgICAgICBjb25zdCBob3N0ID0gbmV0LmlzSVB2NihvcHRzLmhvc3QpID8gYFske29wdHMuaG9zdH1dYCA6IG9wdHMuaG9zdDtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBgQ09OTkVDVCAke2hvc3R9OiR7b3B0cy5wb3J0fSBIVFRQLzEuMVxcclxcbmA7XG4gICAgICAgIC8vIEluamVjdCB0aGUgYFByb3h5LUF1dGhvcml6YXRpb25gIGhlYWRlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChwcm94eS51c2VybmFtZSB8fCBwcm94eS5wYXNzd29yZCkge1xuICAgICAgICAgICAgY29uc3QgYXV0aCA9IGAke2RlY29kZVVSSUNvbXBvbmVudChwcm94eS51c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KHByb3h5LnBhc3N3b3JkKX1gO1xuICAgICAgICAgICAgaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5Ib3N0ID0gYCR7aG9zdH06JHtvcHRzLnBvcnR9YDtcbiAgICAgICAgaWYgKCFoZWFkZXJzWydQcm94eS1Db25uZWN0aW9uJ10pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ1Byb3h5LUNvbm5lY3Rpb24nXSA9IHRoaXMua2VlcEFsaXZlXG4gICAgICAgICAgICAgICAgPyAnS2VlcC1BbGl2ZSdcbiAgICAgICAgICAgICAgICA6ICdjbG9zZSc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBwYXlsb2FkICs9IGAke25hbWV9OiAke2hlYWRlcnNbbmFtZV19XFxyXFxuYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm94eVJlc3BvbnNlUHJvbWlzZSA9ICgwLCBwYXJzZV9wcm94eV9yZXNwb25zZV8xLnBhcnNlUHJveHlSZXNwb25zZSkoc29ja2V0KTtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke3BheWxvYWR9XFxyXFxuYCk7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdCwgYnVmZmVyZWQgfSA9IGF3YWl0IHByb3h5UmVzcG9uc2VQcm9taXNlO1xuICAgICAgICByZXEuZW1pdCgncHJveHlDb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgIHRoaXMuZW1pdCgncHJveHlDb25uZWN0JywgY29ubmVjdCwgcmVxKTtcbiAgICAgICAgaWYgKGNvbm5lY3Quc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXEub25jZSgnc29ja2V0JywgcmVzdW1lKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByb3h5IGlzIGNvbm5lY3RpbmcgdG8gYSBUTFMgc2VydmVyLCBzbyB1cGdyYWRlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzb2NrZXQgY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgIGRlYnVnKCdVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRscy5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub21pdChzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdChvcHRzKSwgJ2hvc3QnLCAncGF0aCcsICdwb3J0JyksXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBvdGhlciBzdGF0dXMgY29kZSB0aGF0J3Mgbm90IDIwMC4uLiBuZWVkIHRvIHJlLXBsYXkgdGhlIEhUVFBcbiAgICAgICAgLy8gaGVhZGVyIFwiZGF0YVwiIGV2ZW50cyBvbnRvIHRoZSBzb2NrZXQgb25jZSB0aGUgSFRUUCBtYWNoaW5lcnkgaXNcbiAgICAgICAgLy8gYXR0YWNoZWQgc28gdGhhdCB0aGUgbm9kZSBjb3JlIGBodHRwYCBjYW4gcGFyc2UgYW5kIGhhbmRsZSB0aGVcbiAgICAgICAgLy8gZXJyb3Igc3RhdHVzIGNvZGUuXG4gICAgICAgIC8vIENsb3NlIHRoZSBvcmlnaW5hbCBzb2NrZXQsIGFuZCBhIG5ldyBcImZha2VcIiBzb2NrZXQgaXMgcmV0dXJuZWRcbiAgICAgICAgLy8gaW5zdGVhZCwgc28gdGhhdCB0aGUgcHJveHkgZG9lc24ndCBnZXQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAgICAvLyB3cml0dGVuIHRvIGl0ICh3aGljaCBtYXkgY29udGFpbiBgQXV0aG9yaXphdGlvbmAgaGVhZGVycyBvciBvdGhlclxuICAgICAgICAvLyBzZW5zaXRpdmUgZGF0YSkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9oYWNrZXJvbmUuY29tL3JlcG9ydHMvNTQxNTAyXG4gICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIGNvbnN0IGZha2VTb2NrZXQgPSBuZXcgbmV0LlNvY2tldCh7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgZmFrZVNvY2tldC5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgIC8vIE5lZWQgdG8gd2FpdCBmb3IgdGhlIFwic29ja2V0XCIgZXZlbnQgdG8gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzLlxuICAgICAgICByZXEub25jZSgnc29ja2V0JywgKHMpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdSZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCcpO1xuICAgICAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKHMubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCk7XG4gICAgICAgICAgICAvLyBSZXBsYXkgdGhlIFwiYnVmZmVyZWRcIiBCdWZmZXIgb250byB0aGUgZmFrZSBgc29ja2V0YCwgc2luY2UgYXRcbiAgICAgICAgICAgIC8vIHRoaXMgcG9pbnQgdGhlIEhUVFAgbW9kdWxlIG1hY2hpbmVyeSBoYXMgYmVlbiBob29rZWQgdXAgZm9yXG4gICAgICAgICAgICAvLyB0aGUgdXNlci5cbiAgICAgICAgICAgIHMucHVzaChidWZmZXJlZCk7XG4gICAgICAgICAgICBzLnB1c2gobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFrZVNvY2tldDtcbiAgICB9XG59XG5IdHRwc1Byb3h5QWdlbnQucHJvdG9jb2xzID0gWydodHRwJywgJ2h0dHBzJ107XG5leHBvcnRzLkh0dHBzUHJveHlBZ2VudCA9IEh0dHBzUHJveHlBZ2VudDtcbmZ1bmN0aW9uIHJlc3VtZShzb2NrZXQpIHtcbiAgICBzb2NrZXQucmVzdW1lKCk7XG59XG5mdW5jdGlvbiBvbWl0KG9iaiwgLi4ua2V5cykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsIkh0dHBzUHJveHlBZ2VudCIsIm5ldCIsInJlcXVpcmUiLCJ0bHMiLCJhc3NlcnRfMSIsImRlYnVnXzEiLCJhZ2VudF9iYXNlXzEiLCJ1cmxfMSIsInBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdCIsIm9wdGlvbnMiLCJzZXJ2ZXJuYW1lIiwiaG9zdCIsImlzSVAiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwicHJveHkiLCJvcHRzIiwicGF0aCIsIlVSTCIsInByb3h5SGVhZGVycyIsImhlYWRlcnMiLCJocmVmIiwiaG9zdG5hbWUiLCJyZXBsYWNlIiwicG9ydCIsInBhcnNlSW50IiwicHJvdG9jb2wiLCJjb25uZWN0T3B0cyIsIkFMUE5Qcm90b2NvbHMiLCJvbWl0IiwiY29ubmVjdCIsInJlcSIsIlR5cGVFcnJvciIsInNvY2tldCIsImlzSVB2NiIsInBheWxvYWQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYXV0aCIsImRlY29kZVVSSUNvbXBvbmVudCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIkhvc3QiLCJrZWVwQWxpdmUiLCJuYW1lIiwia2V5cyIsInByb3h5UmVzcG9uc2VQcm9taXNlIiwicGFyc2VQcm94eVJlc3BvbnNlIiwid3JpdGUiLCJidWZmZXJlZCIsImVtaXQiLCJzdGF0dXNDb2RlIiwib25jZSIsInJlc3VtZSIsInNlY3VyZUVuZHBvaW50IiwiZGVzdHJveSIsImZha2VTb2NrZXQiLCJTb2NrZXQiLCJyZWFkYWJsZSIsInMiLCJsaXN0ZW5lckNvdW50IiwicHVzaCIsInByb3RvY29scyIsIm9iaiIsInJldCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/gaxios/node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseProxyResponse = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"https-proxy-agent:parse-proxy-response\");\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject)=>{\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b) ondata(b);\n            else socket.once(\"readable\", read);\n        }\n        function cleanup() {\n            socket.removeListener(\"end\", onend);\n            socket.removeListener(\"error\", onerror);\n            socket.removeListener(\"readable\", read);\n        }\n        function onend() {\n            cleanup();\n            debug(\"onend\");\n            reject(new Error(\"Proxy connection ended before receiving CONNECT response\"));\n        }\n        function onerror(err) {\n            cleanup();\n            debug(\"onerror %o\", err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf(\"\\r\\n\\r\\n\");\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug(\"have not received end of HTTP headers yet...\");\n                read();\n                return;\n            }\n            const headerParts = buffered.slice(0, endOfHeaders).toString(\"ascii\").split(\"\\r\\n\");\n            const firstLine = headerParts.shift();\n            if (!firstLine) {\n                socket.destroy();\n                return reject(new Error(\"No header received from proxy CONNECT response\"));\n            }\n            const firstLineParts = firstLine.split(\" \");\n            const statusCode = +firstLineParts[1];\n            const statusText = firstLineParts.slice(2).join(\" \");\n            const headers = {};\n            for (const header of headerParts){\n                if (!header) continue;\n                const firstColon = header.indexOf(\":\");\n                if (firstColon === -1) {\n                    socket.destroy();\n                    return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n                }\n                const key = header.slice(0, firstColon).toLowerCase();\n                const value = header.slice(firstColon + 1).trimStart();\n                const current = headers[key];\n                if (typeof current === \"string\") {\n                    headers[key] = [\n                        current,\n                        value\n                    ];\n                } else if (Array.isArray(current)) {\n                    current.push(value);\n                } else {\n                    headers[key] = value;\n                }\n            }\n            debug(\"got proxy server response: %o %o\", firstLine, headers);\n            cleanup();\n            resolve({\n                connect: {\n                    statusCode,\n                    statusText,\n                    headers\n                },\n                buffered\n            });\n        }\n        socket.on(\"error\", onerror);\n        socket.on(\"end\", onend);\n        read();\n    });\n}\nexports.parseProxyResponse = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L3BhcnNlLXByb3h5LXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1HLFVBQVVSLGdCQUFnQlMsbUJBQU9BLENBQUMsc0RBQU87QUFDL0MsTUFBTUMsUUFBUSxDQUFDLEdBQUdGLFFBQVFHLE9BQU8sRUFBRTtBQUNuQyxTQUFTSixtQkFBbUJLLE1BQU07SUFDOUIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCLCtFQUErRTtRQUMvRSxnRkFBZ0Y7UUFDaEYsOEVBQThFO1FBQzlFLDhCQUE4QjtRQUM5QixJQUFJQyxnQkFBZ0I7UUFDcEIsTUFBTUMsVUFBVSxFQUFFO1FBQ2xCLFNBQVNDO1lBQ0wsTUFBTUMsSUFBSVAsT0FBT00sSUFBSTtZQUNyQixJQUFJQyxHQUNBQyxPQUFPRDtpQkFFUFAsT0FBT1MsSUFBSSxDQUFDLFlBQVlIO1FBQ2hDO1FBQ0EsU0FBU0k7WUFDTFYsT0FBT1csY0FBYyxDQUFDLE9BQU9DO1lBQzdCWixPQUFPVyxjQUFjLENBQUMsU0FBU0U7WUFDL0JiLE9BQU9XLGNBQWMsQ0FBQyxZQUFZTDtRQUN0QztRQUNBLFNBQVNNO1lBQ0xGO1lBQ0FaLE1BQU07WUFDTkssT0FBTyxJQUFJVyxNQUFNO1FBQ3JCO1FBQ0EsU0FBU0QsUUFBUUUsR0FBRztZQUNoQkw7WUFDQVosTUFBTSxjQUFjaUI7WUFDcEJaLE9BQU9ZO1FBQ1g7UUFDQSxTQUFTUCxPQUFPRCxDQUFDO1lBQ2JGLFFBQVFXLElBQUksQ0FBQ1Q7WUFDYkgsaUJBQWlCRyxFQUFFVSxNQUFNO1lBQ3pCLE1BQU1DLFdBQVdDLE9BQU9DLE1BQU0sQ0FBQ2YsU0FBU0Q7WUFDeEMsTUFBTWlCLGVBQWVILFNBQVNJLE9BQU8sQ0FBQztZQUN0QyxJQUFJRCxpQkFBaUIsQ0FBQyxHQUFHO2dCQUNyQixpQkFBaUI7Z0JBQ2pCdkIsTUFBTTtnQkFDTlE7Z0JBQ0E7WUFDSjtZQUNBLE1BQU1pQixjQUFjTCxTQUNmTSxLQUFLLENBQUMsR0FBR0gsY0FDVEksUUFBUSxDQUFDLFNBQ1RDLEtBQUssQ0FBQztZQUNYLE1BQU1DLFlBQVlKLFlBQVlLLEtBQUs7WUFDbkMsSUFBSSxDQUFDRCxXQUFXO2dCQUNaM0IsT0FBTzZCLE9BQU87Z0JBQ2QsT0FBTzFCLE9BQU8sSUFBSVcsTUFBTTtZQUM1QjtZQUNBLE1BQU1nQixpQkFBaUJILFVBQVVELEtBQUssQ0FBQztZQUN2QyxNQUFNSyxhQUFhLENBQUNELGNBQWMsQ0FBQyxFQUFFO1lBQ3JDLE1BQU1FLGFBQWFGLGVBQWVOLEtBQUssQ0FBQyxHQUFHUyxJQUFJLENBQUM7WUFDaEQsTUFBTUMsVUFBVSxDQUFDO1lBQ2pCLEtBQUssTUFBTUMsVUFBVVosWUFBYTtnQkFDOUIsSUFBSSxDQUFDWSxRQUNEO2dCQUNKLE1BQU1DLGFBQWFELE9BQU9iLE9BQU8sQ0FBQztnQkFDbEMsSUFBSWMsZUFBZSxDQUFDLEdBQUc7b0JBQ25CcEMsT0FBTzZCLE9BQU87b0JBQ2QsT0FBTzFCLE9BQU8sSUFBSVcsTUFBTSxDQUFDLDZDQUE2QyxFQUFFcUIsT0FBTyxDQUFDLENBQUM7Z0JBQ3JGO2dCQUNBLE1BQU1FLE1BQU1GLE9BQU9YLEtBQUssQ0FBQyxHQUFHWSxZQUFZRSxXQUFXO2dCQUNuRCxNQUFNNUMsUUFBUXlDLE9BQU9YLEtBQUssQ0FBQ1ksYUFBYSxHQUFHRyxTQUFTO2dCQUNwRCxNQUFNQyxVQUFVTixPQUFPLENBQUNHLElBQUk7Z0JBQzVCLElBQUksT0FBT0csWUFBWSxVQUFVO29CQUM3Qk4sT0FBTyxDQUFDRyxJQUFJLEdBQUc7d0JBQUNHO3dCQUFTOUM7cUJBQU07Z0JBQ25DLE9BQ0ssSUFBSStDLE1BQU1DLE9BQU8sQ0FBQ0YsVUFBVTtvQkFDN0JBLFFBQVF4QixJQUFJLENBQUN0QjtnQkFDakIsT0FDSztvQkFDRHdDLE9BQU8sQ0FBQ0csSUFBSSxHQUFHM0M7Z0JBQ25CO1lBQ0o7WUFDQUksTUFBTSxvQ0FBb0M2QixXQUFXTztZQUNyRHhCO1lBQ0FSLFFBQVE7Z0JBQ0p5QyxTQUFTO29CQUNMWjtvQkFDQUM7b0JBQ0FFO2dCQUNKO2dCQUNBaEI7WUFDSjtRQUNKO1FBQ0FsQixPQUFPNEMsRUFBRSxDQUFDLFNBQVMvQjtRQUNuQmIsT0FBTzRDLEVBQUUsQ0FBQyxPQUFPaEM7UUFDakJOO0lBQ0o7QUFDSjtBQUNBYiwwQkFBMEIsR0FBR0Usb0JBQzdCLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmstc2F2ZXItYXV0by1zdW1tYXJ5Ly4vbm9kZV9tb2R1bGVzL2dheGlvcy9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcz9kYjc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVByb3h5UmVzcG9uc2UgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdodHRwcy1wcm94eS1hZ2VudDpwYXJzZS1wcm94eS1yZXNwb25zZScpO1xuZnVuY3Rpb24gcGFyc2VQcm94eVJlc3BvbnNlKHNvY2tldCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYnVmZmVyIGFueSBIVFRQIHRyYWZmaWMgdGhhdCBoYXBwZW5zIHdpdGggdGhlIHByb3h5IGJlZm9yZSB3ZSBnZXRcbiAgICAgICAgLy8gdGhlIENPTk5FQ1QgcmVzcG9uc2UsIHNvIHRoYXQgaWYgdGhlIHJlc3BvbnNlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gXCIyMDBcIlxuICAgICAgICAvLyByZXNwb25zZSBjb2RlLCB0aGVuIHdlIGNhbiByZS1wbGF5IHRoZSBcImRhdGFcIiBldmVudHMgb24gdGhlIHNvY2tldCBvbmNlIHRoZVxuICAgICAgICAvLyBIVFRQIHBhcnNlciBpcyBob29rZWQgdXAuLi5cbiAgICAgICAgbGV0IGJ1ZmZlcnNMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgICAgICBjb25zdCBiID0gc29ja2V0LnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIG9uZGF0YShiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgncmVhZGFibGUnLCByZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Byb3h5IGNvbm5lY3Rpb24gZW5kZWQgYmVmb3JlIHJlY2VpdmluZyBDT05ORUNUIHJlc3BvbnNlJykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBkZWJ1Zygnb25lcnJvciAlbycsIGVycik7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmRhdGEoYikge1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKGIpO1xuICAgICAgICAgICAgYnVmZmVyc0xlbmd0aCArPSBiLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBidWZmZXJzTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZE9mSGVhZGVycyA9IGJ1ZmZlcmVkLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICAgICAgaWYgKGVuZE9mSGVhZGVycyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIGJ1ZmZlcmluZ1xuICAgICAgICAgICAgICAgIGRlYnVnKCdoYXZlIG5vdCByZWNlaXZlZCBlbmQgb2YgSFRUUCBoZWFkZXJzIHlldC4uLicpO1xuICAgICAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJ0cyA9IGJ1ZmZlcmVkXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGVuZE9mSGVhZGVycylcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2FzY2lpJylcbiAgICAgICAgICAgICAgICAuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gaGVhZGVyUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghZmlyc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gaGVhZGVyIHJlY2VpdmVkIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZVBhcnRzID0gZmlyc3RMaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gK2ZpcnN0TGluZVBhcnRzWzFdO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzVGV4dCA9IGZpcnN0TGluZVBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlclBhcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sb24gPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvbG9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgSW52YWxpZCBoZWFkZXIgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlOiBcIiR7aGVhZGVyfVwiYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBoZWFkZXIuc2xpY2UoMCwgZmlyc3RDb2xvbikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5zbGljZShmaXJzdENvbG9uICsgMSkudHJpbVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFtjdXJyZW50LCB2YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKCdnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbyAlbycsIGZpcnN0TGluZSwgaGVhZGVycyk7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBjb25uZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBidWZmZXJlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgIHJlYWQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucGFyc2VQcm94eVJlc3BvbnNlID0gcGFyc2VQcm94eVJlc3BvbnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtcHJveHktcmVzcG9uc2UuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlUHJveHlSZXNwb25zZSIsImRlYnVnXzEiLCJyZXF1aXJlIiwiZGVidWciLCJkZWZhdWx0Iiwic29ja2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJidWZmZXJzTGVuZ3RoIiwiYnVmZmVycyIsInJlYWQiLCJiIiwib25kYXRhIiwib25jZSIsImNsZWFudXAiLCJyZW1vdmVMaXN0ZW5lciIsIm9uZW5kIiwib25lcnJvciIsIkVycm9yIiwiZXJyIiwicHVzaCIsImxlbmd0aCIsImJ1ZmZlcmVkIiwiQnVmZmVyIiwiY29uY2F0IiwiZW5kT2ZIZWFkZXJzIiwiaW5kZXhPZiIsImhlYWRlclBhcnRzIiwic2xpY2UiLCJ0b1N0cmluZyIsInNwbGl0IiwiZmlyc3RMaW5lIiwic2hpZnQiLCJkZXN0cm95IiwiZmlyc3RMaW5lUGFydHMiLCJzdGF0dXNDb2RlIiwic3RhdHVzVGV4dCIsImpvaW4iLCJoZWFkZXJzIiwiaGVhZGVyIiwiZmlyc3RDb2xvbiIsImtleSIsInRvTG93ZXJDYXNlIiwidHJpbVN0YXJ0IiwiY3VycmVudCIsIkFycmF5IiwiaXNBcnJheSIsImNvbm5lY3QiLCJvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/util.cjs":
/*!****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/util.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// Copyright 2023 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"(rsc)/./node_modules/gaxios/package.json\");\nmodule.exports = {\n    pkg\n}; //# sourceMappingURL=util.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvdXRpbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxNQUFNQSxNQUFNQyxtQkFBT0EsQ0FBQztBQUNwQkMsT0FBT0MsT0FBTyxHQUFHO0lBQUVIO0FBQUksR0FDdkIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluay1zYXZlci1hdXRvLXN1bW1hcnkvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvdXRpbC5janM/YzQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHsgcGtnIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmNqcy5tYXAiXSwibmFtZXMiOlsicGtnIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/util.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/package.json":
/*!******************************************!*\
  !*** ./node_modules/gaxios/package.json ***!
  \******************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"gaxios","version":"7.1.1","description":"A simple common HTTP client specifically for Google APIs and services.","main":"build/cjs/src/index.js","types":"build/cjs/src/index.d.ts","files":["build/"],"exports":{".":{"import":{"types":"./build/esm/src/index.d.ts","default":"./build/esm/src/index.js"},"require":{"types":"./build/cjs/src/index.d.ts","default":"./build/cjs/src/index.js"}}},"scripts":{"lint":"gts check --no-inline-config","test":"c8 mocha build/esm/test","presystem-test":"npm run compile","system-test":"mocha build/esm/system-test --timeout 80000","compile":"tsc -b ./tsconfig.json ./tsconfig.cjs.json && node utils/enable-esm.mjs","fix":"gts fix","prepare":"npm run compile","pretest":"npm run compile","webpack":"webpack","prebrowser-test":"npm run compile","browser-test":"node build/browser-test/browser-test-runner.js","docs":"jsdoc -c .jsdoc.js","docs-test":"linkinator docs","predocs-test":"npm run docs","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","prelint":"cd samples; npm link ../; npm install","clean":"gts clean"},"repository":"googleapis/gaxios","keywords":["google"],"engines":{"node":">=18"},"author":"Google, LLC","license":"Apache-2.0","devDependencies":{"@babel/plugin-proposal-private-methods":"^7.18.6","@types/cors":"^2.8.6","@types/express":"^5.0.0","@types/extend":"^3.0.1","@types/mocha":"^10.0.10","@types/multiparty":"4.2.1","@types/mv":"^2.1.0","@types/ncp":"^2.0.1","@types/node":"^22.0.0","@types/sinon":"^17.0.0","@types/tmp":"0.2.6","assert":"^2.0.0","browserify":"^17.0.0","c8":"^10.0.0","cors":"^2.8.5","express":"^5.0.0","gts":"^6.0.0","is-docker":"^3.0.0","jsdoc":"^4.0.0","jsdoc-fresh":"^4.0.0","jsdoc-region-tag":"^3.0.0","karma":"^6.0.0","karma-chrome-launcher":"^3.0.0","karma-coverage":"^2.0.0","karma-firefox-launcher":"^2.0.0","karma-mocha":"^2.0.0","karma-remap-coverage":"^0.1.5","karma-sourcemap-loader":"^0.4.0","karma-webpack":"^5.0.1","linkinator":"^6.1.2","mocha":"^11.1.0","multiparty":"^4.2.1","mv":"^2.1.1","ncp":"^2.0.0","nock":"^14.0.0-beta.13","null-loader":"^4.0.0","pack-n-play":"^3.0.0","puppeteer":"^24.0.0","sinon":"^20.0.0","stream-browserify":"^3.0.0","tmp":"0.2.3","ts-loader":"^9.5.2","typescript":"^5.8.3","webpack":"^5.35.0","webpack-cli":"^6.0.1"},"dependencies":{"extend":"^3.0.2","https-proxy-agent":"^7.0.1","node-fetch":"^3.3.2"}}');

/***/ })

};
;